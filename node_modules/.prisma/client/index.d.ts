
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model maestro
 * 
 */
export type maestro = $Result.DefaultSelection<Prisma.$maestroPayload>
/**
 * Model alumno
 * 
 */
export type alumno = $Result.DefaultSelection<Prisma.$alumnoPayload>
/**
 * Model taller
 * 
 */
export type taller = $Result.DefaultSelection<Prisma.$tallerPayload>
/**
 * Model alumno_taller
 * 
 */
export type alumno_taller = $Result.DefaultSelection<Prisma.$alumno_tallerPayload>
/**
 * Model comprobante
 * 
 */
export type comprobante = $Result.DefaultSelection<Prisma.$comprobantePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Maestros
 * const maestros = await prisma.maestro.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Maestros
   * const maestros = await prisma.maestro.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.maestro`: Exposes CRUD operations for the **maestro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maestros
    * const maestros = await prisma.maestro.findMany()
    * ```
    */
  get maestro(): Prisma.maestroDelegate<ExtArgs>;

  /**
   * `prisma.alumno`: Exposes CRUD operations for the **alumno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alumnos
    * const alumnos = await prisma.alumno.findMany()
    * ```
    */
  get alumno(): Prisma.alumnoDelegate<ExtArgs>;

  /**
   * `prisma.taller`: Exposes CRUD operations for the **taller** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tallers
    * const tallers = await prisma.taller.findMany()
    * ```
    */
  get taller(): Prisma.tallerDelegate<ExtArgs>;

  /**
   * `prisma.alumno_taller`: Exposes CRUD operations for the **alumno_taller** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alumno_tallers
    * const alumno_tallers = await prisma.alumno_taller.findMany()
    * ```
    */
  get alumno_taller(): Prisma.alumno_tallerDelegate<ExtArgs>;

  /**
   * `prisma.comprobante`: Exposes CRUD operations for the **comprobante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comprobantes
    * const comprobantes = await prisma.comprobante.findMany()
    * ```
    */
  get comprobante(): Prisma.comprobanteDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    maestro: 'maestro',
    alumno: 'alumno',
    taller: 'taller',
    alumno_taller: 'alumno_taller',
    comprobante: 'comprobante'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "maestro" | "alumno" | "taller" | "alumno_taller" | "comprobante"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      maestro: {
        payload: Prisma.$maestroPayload<ExtArgs>
        fields: Prisma.maestroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.maestroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.maestroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestroPayload>
          }
          findFirst: {
            args: Prisma.maestroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.maestroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestroPayload>
          }
          findMany: {
            args: Prisma.maestroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestroPayload>[]
          }
          create: {
            args: Prisma.maestroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestroPayload>
          }
          createMany: {
            args: Prisma.maestroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.maestroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestroPayload>[]
          }
          delete: {
            args: Prisma.maestroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestroPayload>
          }
          update: {
            args: Prisma.maestroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestroPayload>
          }
          deleteMany: {
            args: Prisma.maestroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.maestroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.maestroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maestroPayload>
          }
          aggregate: {
            args: Prisma.MaestroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaestro>
          }
          groupBy: {
            args: Prisma.maestroGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaestroGroupByOutputType>[]
          }
          count: {
            args: Prisma.maestroCountArgs<ExtArgs>
            result: $Utils.Optional<MaestroCountAggregateOutputType> | number
          }
        }
      }
      alumno: {
        payload: Prisma.$alumnoPayload<ExtArgs>
        fields: Prisma.alumnoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.alumnoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumnoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.alumnoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumnoPayload>
          }
          findFirst: {
            args: Prisma.alumnoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumnoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.alumnoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumnoPayload>
          }
          findMany: {
            args: Prisma.alumnoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumnoPayload>[]
          }
          create: {
            args: Prisma.alumnoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumnoPayload>
          }
          createMany: {
            args: Prisma.alumnoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.alumnoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumnoPayload>[]
          }
          delete: {
            args: Prisma.alumnoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumnoPayload>
          }
          update: {
            args: Prisma.alumnoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumnoPayload>
          }
          deleteMany: {
            args: Prisma.alumnoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.alumnoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.alumnoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumnoPayload>
          }
          aggregate: {
            args: Prisma.AlumnoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlumno>
          }
          groupBy: {
            args: Prisma.alumnoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlumnoGroupByOutputType>[]
          }
          count: {
            args: Prisma.alumnoCountArgs<ExtArgs>
            result: $Utils.Optional<AlumnoCountAggregateOutputType> | number
          }
        }
      }
      taller: {
        payload: Prisma.$tallerPayload<ExtArgs>
        fields: Prisma.tallerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tallerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tallerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tallerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tallerPayload>
          }
          findFirst: {
            args: Prisma.tallerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tallerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tallerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tallerPayload>
          }
          findMany: {
            args: Prisma.tallerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tallerPayload>[]
          }
          create: {
            args: Prisma.tallerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tallerPayload>
          }
          createMany: {
            args: Prisma.tallerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tallerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tallerPayload>[]
          }
          delete: {
            args: Prisma.tallerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tallerPayload>
          }
          update: {
            args: Prisma.tallerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tallerPayload>
          }
          deleteMany: {
            args: Prisma.tallerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tallerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tallerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tallerPayload>
          }
          aggregate: {
            args: Prisma.TallerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaller>
          }
          groupBy: {
            args: Prisma.tallerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TallerGroupByOutputType>[]
          }
          count: {
            args: Prisma.tallerCountArgs<ExtArgs>
            result: $Utils.Optional<TallerCountAggregateOutputType> | number
          }
        }
      }
      alumno_taller: {
        payload: Prisma.$alumno_tallerPayload<ExtArgs>
        fields: Prisma.alumno_tallerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.alumno_tallerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumno_tallerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.alumno_tallerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumno_tallerPayload>
          }
          findFirst: {
            args: Prisma.alumno_tallerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumno_tallerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.alumno_tallerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumno_tallerPayload>
          }
          findMany: {
            args: Prisma.alumno_tallerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumno_tallerPayload>[]
          }
          create: {
            args: Prisma.alumno_tallerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumno_tallerPayload>
          }
          createMany: {
            args: Prisma.alumno_tallerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.alumno_tallerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumno_tallerPayload>[]
          }
          delete: {
            args: Prisma.alumno_tallerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumno_tallerPayload>
          }
          update: {
            args: Prisma.alumno_tallerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumno_tallerPayload>
          }
          deleteMany: {
            args: Prisma.alumno_tallerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.alumno_tallerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.alumno_tallerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alumno_tallerPayload>
          }
          aggregate: {
            args: Prisma.Alumno_tallerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlumno_taller>
          }
          groupBy: {
            args: Prisma.alumno_tallerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Alumno_tallerGroupByOutputType>[]
          }
          count: {
            args: Prisma.alumno_tallerCountArgs<ExtArgs>
            result: $Utils.Optional<Alumno_tallerCountAggregateOutputType> | number
          }
        }
      }
      comprobante: {
        payload: Prisma.$comprobantePayload<ExtArgs>
        fields: Prisma.comprobanteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comprobanteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprobantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comprobanteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprobantePayload>
          }
          findFirst: {
            args: Prisma.comprobanteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprobantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comprobanteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprobantePayload>
          }
          findMany: {
            args: Prisma.comprobanteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprobantePayload>[]
          }
          create: {
            args: Prisma.comprobanteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprobantePayload>
          }
          createMany: {
            args: Prisma.comprobanteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.comprobanteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprobantePayload>[]
          }
          delete: {
            args: Prisma.comprobanteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprobantePayload>
          }
          update: {
            args: Prisma.comprobanteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprobantePayload>
          }
          deleteMany: {
            args: Prisma.comprobanteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comprobanteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.comprobanteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprobantePayload>
          }
          aggregate: {
            args: Prisma.ComprobanteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComprobante>
          }
          groupBy: {
            args: Prisma.comprobanteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComprobanteGroupByOutputType>[]
          }
          count: {
            args: Prisma.comprobanteCountArgs<ExtArgs>
            result: $Utils.Optional<ComprobanteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MaestroCountOutputType
   */

  export type MaestroCountOutputType = {
    talleres: number
  }

  export type MaestroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    talleres?: boolean | MaestroCountOutputTypeCountTalleresArgs
  }

  // Custom InputTypes
  /**
   * MaestroCountOutputType without action
   */
  export type MaestroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaestroCountOutputType
     */
    select?: MaestroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaestroCountOutputType without action
   */
  export type MaestroCountOutputTypeCountTalleresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tallerWhereInput
  }


  /**
   * Count Type AlumnoCountOutputType
   */

  export type AlumnoCountOutputType = {
    inscripciones: number
    comprobantes: number
  }

  export type AlumnoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripciones?: boolean | AlumnoCountOutputTypeCountInscripcionesArgs
    comprobantes?: boolean | AlumnoCountOutputTypeCountComprobantesArgs
  }

  // Custom InputTypes
  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlumnoCountOutputType
     */
    select?: AlumnoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountInscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alumno_tallerWhereInput
  }

  /**
   * AlumnoCountOutputType without action
   */
  export type AlumnoCountOutputTypeCountComprobantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprobanteWhereInput
  }


  /**
   * Count Type TallerCountOutputType
   */

  export type TallerCountOutputType = {
    alumnos: number
    comprobantes: number
  }

  export type TallerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumnos?: boolean | TallerCountOutputTypeCountAlumnosArgs
    comprobantes?: boolean | TallerCountOutputTypeCountComprobantesArgs
  }

  // Custom InputTypes
  /**
   * TallerCountOutputType without action
   */
  export type TallerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TallerCountOutputType
     */
    select?: TallerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TallerCountOutputType without action
   */
  export type TallerCountOutputTypeCountAlumnosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alumno_tallerWhereInput
  }

  /**
   * TallerCountOutputType without action
   */
  export type TallerCountOutputTypeCountComprobantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprobanteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model maestro
   */

  export type AggregateMaestro = {
    _count: MaestroCountAggregateOutputType | null
    _avg: MaestroAvgAggregateOutputType | null
    _sum: MaestroSumAggregateOutputType | null
    _min: MaestroMinAggregateOutputType | null
    _max: MaestroMaxAggregateOutputType | null
  }

  export type MaestroAvgAggregateOutputType = {
    id_maestro: number | null
    cant_talleres: number | null
  }

  export type MaestroSumAggregateOutputType = {
    id_maestro: number | null
    cant_talleres: number | null
  }

  export type MaestroMinAggregateOutputType = {
    id_maestro: number | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    telefono: string | null
    cant_talleres: number | null
  }

  export type MaestroMaxAggregateOutputType = {
    id_maestro: number | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    telefono: string | null
    cant_talleres: number | null
  }

  export type MaestroCountAggregateOutputType = {
    id_maestro: number
    nombre: number
    apellido: number
    dni: number
    telefono: number
    cant_talleres: number
    _all: number
  }


  export type MaestroAvgAggregateInputType = {
    id_maestro?: true
    cant_talleres?: true
  }

  export type MaestroSumAggregateInputType = {
    id_maestro?: true
    cant_talleres?: true
  }

  export type MaestroMinAggregateInputType = {
    id_maestro?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    cant_talleres?: true
  }

  export type MaestroMaxAggregateInputType = {
    id_maestro?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    cant_talleres?: true
  }

  export type MaestroCountAggregateInputType = {
    id_maestro?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    cant_talleres?: true
    _all?: true
  }

  export type MaestroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maestro to aggregate.
     */
    where?: maestroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maestros to fetch.
     */
    orderBy?: maestroOrderByWithRelationInput | maestroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: maestroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maestros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maestros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned maestros
    **/
    _count?: true | MaestroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaestroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaestroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaestroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaestroMaxAggregateInputType
  }

  export type GetMaestroAggregateType<T extends MaestroAggregateArgs> = {
        [P in keyof T & keyof AggregateMaestro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaestro[P]>
      : GetScalarType<T[P], AggregateMaestro[P]>
  }




  export type maestroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: maestroWhereInput
    orderBy?: maestroOrderByWithAggregationInput | maestroOrderByWithAggregationInput[]
    by: MaestroScalarFieldEnum[] | MaestroScalarFieldEnum
    having?: maestroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaestroCountAggregateInputType | true
    _avg?: MaestroAvgAggregateInputType
    _sum?: MaestroSumAggregateInputType
    _min?: MaestroMinAggregateInputType
    _max?: MaestroMaxAggregateInputType
  }

  export type MaestroGroupByOutputType = {
    id_maestro: number
    nombre: string
    apellido: string
    dni: string | null
    telefono: string | null
    cant_talleres: number
    _count: MaestroCountAggregateOutputType | null
    _avg: MaestroAvgAggregateOutputType | null
    _sum: MaestroSumAggregateOutputType | null
    _min: MaestroMinAggregateOutputType | null
    _max: MaestroMaxAggregateOutputType | null
  }

  type GetMaestroGroupByPayload<T extends maestroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaestroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaestroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaestroGroupByOutputType[P]>
            : GetScalarType<T[P], MaestroGroupByOutputType[P]>
        }
      >
    >


  export type maestroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_maestro?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    cant_talleres?: boolean
    talleres?: boolean | maestro$talleresArgs<ExtArgs>
    _count?: boolean | MaestroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maestro"]>

  export type maestroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_maestro?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    cant_talleres?: boolean
  }, ExtArgs["result"]["maestro"]>

  export type maestroSelectScalar = {
    id_maestro?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    cant_talleres?: boolean
  }

  export type maestroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    talleres?: boolean | maestro$talleresArgs<ExtArgs>
    _count?: boolean | MaestroCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type maestroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $maestroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "maestro"
    objects: {
      talleres: Prisma.$tallerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_maestro: number
      nombre: string
      apellido: string
      dni: string | null
      telefono: string | null
      cant_talleres: number
    }, ExtArgs["result"]["maestro"]>
    composites: {}
  }

  type maestroGetPayload<S extends boolean | null | undefined | maestroDefaultArgs> = $Result.GetResult<Prisma.$maestroPayload, S>

  type maestroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<maestroFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaestroCountAggregateInputType | true
    }

  export interface maestroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['maestro'], meta: { name: 'maestro' } }
    /**
     * Find zero or one Maestro that matches the filter.
     * @param {maestroFindUniqueArgs} args - Arguments to find a Maestro
     * @example
     * // Get one Maestro
     * const maestro = await prisma.maestro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends maestroFindUniqueArgs>(args: SelectSubset<T, maestroFindUniqueArgs<ExtArgs>>): Prisma__maestroClient<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Maestro that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {maestroFindUniqueOrThrowArgs} args - Arguments to find a Maestro
     * @example
     * // Get one Maestro
     * const maestro = await prisma.maestro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends maestroFindUniqueOrThrowArgs>(args: SelectSubset<T, maestroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__maestroClient<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Maestro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestroFindFirstArgs} args - Arguments to find a Maestro
     * @example
     * // Get one Maestro
     * const maestro = await prisma.maestro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends maestroFindFirstArgs>(args?: SelectSubset<T, maestroFindFirstArgs<ExtArgs>>): Prisma__maestroClient<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Maestro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestroFindFirstOrThrowArgs} args - Arguments to find a Maestro
     * @example
     * // Get one Maestro
     * const maestro = await prisma.maestro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends maestroFindFirstOrThrowArgs>(args?: SelectSubset<T, maestroFindFirstOrThrowArgs<ExtArgs>>): Prisma__maestroClient<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Maestros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maestros
     * const maestros = await prisma.maestro.findMany()
     * 
     * // Get first 10 Maestros
     * const maestros = await prisma.maestro.findMany({ take: 10 })
     * 
     * // Only select the `id_maestro`
     * const maestroWithId_maestroOnly = await prisma.maestro.findMany({ select: { id_maestro: true } })
     * 
     */
    findMany<T extends maestroFindManyArgs>(args?: SelectSubset<T, maestroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Maestro.
     * @param {maestroCreateArgs} args - Arguments to create a Maestro.
     * @example
     * // Create one Maestro
     * const Maestro = await prisma.maestro.create({
     *   data: {
     *     // ... data to create a Maestro
     *   }
     * })
     * 
     */
    create<T extends maestroCreateArgs>(args: SelectSubset<T, maestroCreateArgs<ExtArgs>>): Prisma__maestroClient<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Maestros.
     * @param {maestroCreateManyArgs} args - Arguments to create many Maestros.
     * @example
     * // Create many Maestros
     * const maestro = await prisma.maestro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends maestroCreateManyArgs>(args?: SelectSubset<T, maestroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maestros and returns the data saved in the database.
     * @param {maestroCreateManyAndReturnArgs} args - Arguments to create many Maestros.
     * @example
     * // Create many Maestros
     * const maestro = await prisma.maestro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maestros and only return the `id_maestro`
     * const maestroWithId_maestroOnly = await prisma.maestro.createManyAndReturn({ 
     *   select: { id_maestro: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends maestroCreateManyAndReturnArgs>(args?: SelectSubset<T, maestroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Maestro.
     * @param {maestroDeleteArgs} args - Arguments to delete one Maestro.
     * @example
     * // Delete one Maestro
     * const Maestro = await prisma.maestro.delete({
     *   where: {
     *     // ... filter to delete one Maestro
     *   }
     * })
     * 
     */
    delete<T extends maestroDeleteArgs>(args: SelectSubset<T, maestroDeleteArgs<ExtArgs>>): Prisma__maestroClient<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Maestro.
     * @param {maestroUpdateArgs} args - Arguments to update one Maestro.
     * @example
     * // Update one Maestro
     * const maestro = await prisma.maestro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends maestroUpdateArgs>(args: SelectSubset<T, maestroUpdateArgs<ExtArgs>>): Prisma__maestroClient<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Maestros.
     * @param {maestroDeleteManyArgs} args - Arguments to filter Maestros to delete.
     * @example
     * // Delete a few Maestros
     * const { count } = await prisma.maestro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends maestroDeleteManyArgs>(args?: SelectSubset<T, maestroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maestros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maestros
     * const maestro = await prisma.maestro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends maestroUpdateManyArgs>(args: SelectSubset<T, maestroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Maestro.
     * @param {maestroUpsertArgs} args - Arguments to update or create a Maestro.
     * @example
     * // Update or create a Maestro
     * const maestro = await prisma.maestro.upsert({
     *   create: {
     *     // ... data to create a Maestro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maestro we want to update
     *   }
     * })
     */
    upsert<T extends maestroUpsertArgs>(args: SelectSubset<T, maestroUpsertArgs<ExtArgs>>): Prisma__maestroClient<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Maestros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestroCountArgs} args - Arguments to filter Maestros to count.
     * @example
     * // Count the number of Maestros
     * const count = await prisma.maestro.count({
     *   where: {
     *     // ... the filter for the Maestros we want to count
     *   }
     * })
    **/
    count<T extends maestroCountArgs>(
      args?: Subset<T, maestroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaestroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maestro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaestroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaestroAggregateArgs>(args: Subset<T, MaestroAggregateArgs>): Prisma.PrismaPromise<GetMaestroAggregateType<T>>

    /**
     * Group by Maestro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maestroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends maestroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: maestroGroupByArgs['orderBy'] }
        : { orderBy?: maestroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, maestroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaestroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the maestro model
   */
  readonly fields: maestroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for maestro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__maestroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    talleres<T extends maestro$talleresArgs<ExtArgs> = {}>(args?: Subset<T, maestro$talleresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the maestro model
   */ 
  interface maestroFieldRefs {
    readonly id_maestro: FieldRef<"maestro", 'Int'>
    readonly nombre: FieldRef<"maestro", 'String'>
    readonly apellido: FieldRef<"maestro", 'String'>
    readonly dni: FieldRef<"maestro", 'String'>
    readonly telefono: FieldRef<"maestro", 'String'>
    readonly cant_talleres: FieldRef<"maestro", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * maestro findUnique
   */
  export type maestroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maestroInclude<ExtArgs> | null
    /**
     * Filter, which maestro to fetch.
     */
    where: maestroWhereUniqueInput
  }

  /**
   * maestro findUniqueOrThrow
   */
  export type maestroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maestroInclude<ExtArgs> | null
    /**
     * Filter, which maestro to fetch.
     */
    where: maestroWhereUniqueInput
  }

  /**
   * maestro findFirst
   */
  export type maestroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maestroInclude<ExtArgs> | null
    /**
     * Filter, which maestro to fetch.
     */
    where?: maestroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maestros to fetch.
     */
    orderBy?: maestroOrderByWithRelationInput | maestroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maestros.
     */
    cursor?: maestroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maestros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maestros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maestros.
     */
    distinct?: MaestroScalarFieldEnum | MaestroScalarFieldEnum[]
  }

  /**
   * maestro findFirstOrThrow
   */
  export type maestroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maestroInclude<ExtArgs> | null
    /**
     * Filter, which maestro to fetch.
     */
    where?: maestroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maestros to fetch.
     */
    orderBy?: maestroOrderByWithRelationInput | maestroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maestros.
     */
    cursor?: maestroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maestros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maestros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maestros.
     */
    distinct?: MaestroScalarFieldEnum | MaestroScalarFieldEnum[]
  }

  /**
   * maestro findMany
   */
  export type maestroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maestroInclude<ExtArgs> | null
    /**
     * Filter, which maestros to fetch.
     */
    where?: maestroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maestros to fetch.
     */
    orderBy?: maestroOrderByWithRelationInput | maestroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing maestros.
     */
    cursor?: maestroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maestros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maestros.
     */
    skip?: number
    distinct?: MaestroScalarFieldEnum | MaestroScalarFieldEnum[]
  }

  /**
   * maestro create
   */
  export type maestroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maestroInclude<ExtArgs> | null
    /**
     * The data needed to create a maestro.
     */
    data: XOR<maestroCreateInput, maestroUncheckedCreateInput>
  }

  /**
   * maestro createMany
   */
  export type maestroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many maestros.
     */
    data: maestroCreateManyInput | maestroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * maestro createManyAndReturn
   */
  export type maestroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many maestros.
     */
    data: maestroCreateManyInput | maestroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * maestro update
   */
  export type maestroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maestroInclude<ExtArgs> | null
    /**
     * The data needed to update a maestro.
     */
    data: XOR<maestroUpdateInput, maestroUncheckedUpdateInput>
    /**
     * Choose, which maestro to update.
     */
    where: maestroWhereUniqueInput
  }

  /**
   * maestro updateMany
   */
  export type maestroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update maestros.
     */
    data: XOR<maestroUpdateManyMutationInput, maestroUncheckedUpdateManyInput>
    /**
     * Filter which maestros to update
     */
    where?: maestroWhereInput
  }

  /**
   * maestro upsert
   */
  export type maestroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maestroInclude<ExtArgs> | null
    /**
     * The filter to search for the maestro to update in case it exists.
     */
    where: maestroWhereUniqueInput
    /**
     * In case the maestro found by the `where` argument doesn't exist, create a new maestro with this data.
     */
    create: XOR<maestroCreateInput, maestroUncheckedCreateInput>
    /**
     * In case the maestro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<maestroUpdateInput, maestroUncheckedUpdateInput>
  }

  /**
   * maestro delete
   */
  export type maestroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maestroInclude<ExtArgs> | null
    /**
     * Filter which maestro to delete.
     */
    where: maestroWhereUniqueInput
  }

  /**
   * maestro deleteMany
   */
  export type maestroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maestros to delete
     */
    where?: maestroWhereInput
  }

  /**
   * maestro.talleres
   */
  export type maestro$talleresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    where?: tallerWhereInput
    orderBy?: tallerOrderByWithRelationInput | tallerOrderByWithRelationInput[]
    cursor?: tallerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TallerScalarFieldEnum | TallerScalarFieldEnum[]
  }

  /**
   * maestro without action
   */
  export type maestroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maestro
     */
    select?: maestroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maestroInclude<ExtArgs> | null
  }


  /**
   * Model alumno
   */

  export type AggregateAlumno = {
    _count: AlumnoCountAggregateOutputType | null
    _avg: AlumnoAvgAggregateOutputType | null
    _sum: AlumnoSumAggregateOutputType | null
    _min: AlumnoMinAggregateOutputType | null
    _max: AlumnoMaxAggregateOutputType | null
  }

  export type AlumnoAvgAggregateOutputType = {
    id_alumno: number | null
  }

  export type AlumnoSumAggregateOutputType = {
    id_alumno: number | null
  }

  export type AlumnoMinAggregateOutputType = {
    id_alumno: number | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    direccion: string | null
    telefono_madre: string | null
    telefono_padre: string | null
  }

  export type AlumnoMaxAggregateOutputType = {
    id_alumno: number | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    direccion: string | null
    telefono_madre: string | null
    telefono_padre: string | null
  }

  export type AlumnoCountAggregateOutputType = {
    id_alumno: number
    nombre: number
    apellido: number
    dni: number
    direccion: number
    telefono_madre: number
    telefono_padre: number
    _all: number
  }


  export type AlumnoAvgAggregateInputType = {
    id_alumno?: true
  }

  export type AlumnoSumAggregateInputType = {
    id_alumno?: true
  }

  export type AlumnoMinAggregateInputType = {
    id_alumno?: true
    nombre?: true
    apellido?: true
    dni?: true
    direccion?: true
    telefono_madre?: true
    telefono_padre?: true
  }

  export type AlumnoMaxAggregateInputType = {
    id_alumno?: true
    nombre?: true
    apellido?: true
    dni?: true
    direccion?: true
    telefono_madre?: true
    telefono_padre?: true
  }

  export type AlumnoCountAggregateInputType = {
    id_alumno?: true
    nombre?: true
    apellido?: true
    dni?: true
    direccion?: true
    telefono_madre?: true
    telefono_padre?: true
    _all?: true
  }

  export type AlumnoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alumno to aggregate.
     */
    where?: alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumnos to fetch.
     */
    orderBy?: alumnoOrderByWithRelationInput | alumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alumnos
    **/
    _count?: true | AlumnoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlumnoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlumnoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlumnoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlumnoMaxAggregateInputType
  }

  export type GetAlumnoAggregateType<T extends AlumnoAggregateArgs> = {
        [P in keyof T & keyof AggregateAlumno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlumno[P]>
      : GetScalarType<T[P], AggregateAlumno[P]>
  }




  export type alumnoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alumnoWhereInput
    orderBy?: alumnoOrderByWithAggregationInput | alumnoOrderByWithAggregationInput[]
    by: AlumnoScalarFieldEnum[] | AlumnoScalarFieldEnum
    having?: alumnoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlumnoCountAggregateInputType | true
    _avg?: AlumnoAvgAggregateInputType
    _sum?: AlumnoSumAggregateInputType
    _min?: AlumnoMinAggregateInputType
    _max?: AlumnoMaxAggregateInputType
  }

  export type AlumnoGroupByOutputType = {
    id_alumno: number
    nombre: string
    apellido: string
    dni: string | null
    direccion: string | null
    telefono_madre: string | null
    telefono_padre: string | null
    _count: AlumnoCountAggregateOutputType | null
    _avg: AlumnoAvgAggregateOutputType | null
    _sum: AlumnoSumAggregateOutputType | null
    _min: AlumnoMinAggregateOutputType | null
    _max: AlumnoMaxAggregateOutputType | null
  }

  type GetAlumnoGroupByPayload<T extends alumnoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlumnoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlumnoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlumnoGroupByOutputType[P]>
            : GetScalarType<T[P], AlumnoGroupByOutputType[P]>
        }
      >
    >


  export type alumnoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_alumno?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    direccion?: boolean
    telefono_madre?: boolean
    telefono_padre?: boolean
    inscripciones?: boolean | alumno$inscripcionesArgs<ExtArgs>
    comprobantes?: boolean | alumno$comprobantesArgs<ExtArgs>
    _count?: boolean | AlumnoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alumno"]>

  export type alumnoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_alumno?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    direccion?: boolean
    telefono_madre?: boolean
    telefono_padre?: boolean
  }, ExtArgs["result"]["alumno"]>

  export type alumnoSelectScalar = {
    id_alumno?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    direccion?: boolean
    telefono_madre?: boolean
    telefono_padre?: boolean
  }

  export type alumnoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripciones?: boolean | alumno$inscripcionesArgs<ExtArgs>
    comprobantes?: boolean | alumno$comprobantesArgs<ExtArgs>
    _count?: boolean | AlumnoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type alumnoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $alumnoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "alumno"
    objects: {
      inscripciones: Prisma.$alumno_tallerPayload<ExtArgs>[]
      comprobantes: Prisma.$comprobantePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_alumno: number
      nombre: string
      apellido: string
      dni: string | null
      direccion: string | null
      telefono_madre: string | null
      telefono_padre: string | null
    }, ExtArgs["result"]["alumno"]>
    composites: {}
  }

  type alumnoGetPayload<S extends boolean | null | undefined | alumnoDefaultArgs> = $Result.GetResult<Prisma.$alumnoPayload, S>

  type alumnoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<alumnoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlumnoCountAggregateInputType | true
    }

  export interface alumnoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['alumno'], meta: { name: 'alumno' } }
    /**
     * Find zero or one Alumno that matches the filter.
     * @param {alumnoFindUniqueArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends alumnoFindUniqueArgs>(args: SelectSubset<T, alumnoFindUniqueArgs<ExtArgs>>): Prisma__alumnoClient<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alumno that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {alumnoFindUniqueOrThrowArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends alumnoFindUniqueOrThrowArgs>(args: SelectSubset<T, alumnoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__alumnoClient<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alumno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoFindFirstArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends alumnoFindFirstArgs>(args?: SelectSubset<T, alumnoFindFirstArgs<ExtArgs>>): Prisma__alumnoClient<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alumno that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoFindFirstOrThrowArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends alumnoFindFirstOrThrowArgs>(args?: SelectSubset<T, alumnoFindFirstOrThrowArgs<ExtArgs>>): Prisma__alumnoClient<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alumnos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alumnos
     * const alumnos = await prisma.alumno.findMany()
     * 
     * // Get first 10 Alumnos
     * const alumnos = await prisma.alumno.findMany({ take: 10 })
     * 
     * // Only select the `id_alumno`
     * const alumnoWithId_alumnoOnly = await prisma.alumno.findMany({ select: { id_alumno: true } })
     * 
     */
    findMany<T extends alumnoFindManyArgs>(args?: SelectSubset<T, alumnoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alumno.
     * @param {alumnoCreateArgs} args - Arguments to create a Alumno.
     * @example
     * // Create one Alumno
     * const Alumno = await prisma.alumno.create({
     *   data: {
     *     // ... data to create a Alumno
     *   }
     * })
     * 
     */
    create<T extends alumnoCreateArgs>(args: SelectSubset<T, alumnoCreateArgs<ExtArgs>>): Prisma__alumnoClient<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alumnos.
     * @param {alumnoCreateManyArgs} args - Arguments to create many Alumnos.
     * @example
     * // Create many Alumnos
     * const alumno = await prisma.alumno.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends alumnoCreateManyArgs>(args?: SelectSubset<T, alumnoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alumnos and returns the data saved in the database.
     * @param {alumnoCreateManyAndReturnArgs} args - Arguments to create many Alumnos.
     * @example
     * // Create many Alumnos
     * const alumno = await prisma.alumno.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alumnos and only return the `id_alumno`
     * const alumnoWithId_alumnoOnly = await prisma.alumno.createManyAndReturn({ 
     *   select: { id_alumno: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends alumnoCreateManyAndReturnArgs>(args?: SelectSubset<T, alumnoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alumno.
     * @param {alumnoDeleteArgs} args - Arguments to delete one Alumno.
     * @example
     * // Delete one Alumno
     * const Alumno = await prisma.alumno.delete({
     *   where: {
     *     // ... filter to delete one Alumno
     *   }
     * })
     * 
     */
    delete<T extends alumnoDeleteArgs>(args: SelectSubset<T, alumnoDeleteArgs<ExtArgs>>): Prisma__alumnoClient<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alumno.
     * @param {alumnoUpdateArgs} args - Arguments to update one Alumno.
     * @example
     * // Update one Alumno
     * const alumno = await prisma.alumno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends alumnoUpdateArgs>(args: SelectSubset<T, alumnoUpdateArgs<ExtArgs>>): Prisma__alumnoClient<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alumnos.
     * @param {alumnoDeleteManyArgs} args - Arguments to filter Alumnos to delete.
     * @example
     * // Delete a few Alumnos
     * const { count } = await prisma.alumno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends alumnoDeleteManyArgs>(args?: SelectSubset<T, alumnoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alumnos
     * const alumno = await prisma.alumno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends alumnoUpdateManyArgs>(args: SelectSubset<T, alumnoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alumno.
     * @param {alumnoUpsertArgs} args - Arguments to update or create a Alumno.
     * @example
     * // Update or create a Alumno
     * const alumno = await prisma.alumno.upsert({
     *   create: {
     *     // ... data to create a Alumno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alumno we want to update
     *   }
     * })
     */
    upsert<T extends alumnoUpsertArgs>(args: SelectSubset<T, alumnoUpsertArgs<ExtArgs>>): Prisma__alumnoClient<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoCountArgs} args - Arguments to filter Alumnos to count.
     * @example
     * // Count the number of Alumnos
     * const count = await prisma.alumno.count({
     *   where: {
     *     // ... the filter for the Alumnos we want to count
     *   }
     * })
    **/
    count<T extends alumnoCountArgs>(
      args?: Subset<T, alumnoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlumnoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlumnoAggregateArgs>(args: Subset<T, AlumnoAggregateArgs>): Prisma.PrismaPromise<GetAlumnoAggregateType<T>>

    /**
     * Group by Alumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumnoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alumnoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alumnoGroupByArgs['orderBy'] }
        : { orderBy?: alumnoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alumnoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlumnoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the alumno model
   */
  readonly fields: alumnoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for alumno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__alumnoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inscripciones<T extends alumno$inscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, alumno$inscripcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "findMany"> | Null>
    comprobantes<T extends alumno$comprobantesArgs<ExtArgs> = {}>(args?: Subset<T, alumno$comprobantesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the alumno model
   */ 
  interface alumnoFieldRefs {
    readonly id_alumno: FieldRef<"alumno", 'Int'>
    readonly nombre: FieldRef<"alumno", 'String'>
    readonly apellido: FieldRef<"alumno", 'String'>
    readonly dni: FieldRef<"alumno", 'String'>
    readonly direccion: FieldRef<"alumno", 'String'>
    readonly telefono_madre: FieldRef<"alumno", 'String'>
    readonly telefono_padre: FieldRef<"alumno", 'String'>
  }
    

  // Custom InputTypes
  /**
   * alumno findUnique
   */
  export type alumnoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumnoInclude<ExtArgs> | null
    /**
     * Filter, which alumno to fetch.
     */
    where: alumnoWhereUniqueInput
  }

  /**
   * alumno findUniqueOrThrow
   */
  export type alumnoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumnoInclude<ExtArgs> | null
    /**
     * Filter, which alumno to fetch.
     */
    where: alumnoWhereUniqueInput
  }

  /**
   * alumno findFirst
   */
  export type alumnoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumnoInclude<ExtArgs> | null
    /**
     * Filter, which alumno to fetch.
     */
    where?: alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumnos to fetch.
     */
    orderBy?: alumnoOrderByWithRelationInput | alumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alumnos.
     */
    cursor?: alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alumnos.
     */
    distinct?: AlumnoScalarFieldEnum | AlumnoScalarFieldEnum[]
  }

  /**
   * alumno findFirstOrThrow
   */
  export type alumnoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumnoInclude<ExtArgs> | null
    /**
     * Filter, which alumno to fetch.
     */
    where?: alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumnos to fetch.
     */
    orderBy?: alumnoOrderByWithRelationInput | alumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alumnos.
     */
    cursor?: alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumnos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alumnos.
     */
    distinct?: AlumnoScalarFieldEnum | AlumnoScalarFieldEnum[]
  }

  /**
   * alumno findMany
   */
  export type alumnoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumnoInclude<ExtArgs> | null
    /**
     * Filter, which alumnos to fetch.
     */
    where?: alumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumnos to fetch.
     */
    orderBy?: alumnoOrderByWithRelationInput | alumnoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alumnos.
     */
    cursor?: alumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumnos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumnos.
     */
    skip?: number
    distinct?: AlumnoScalarFieldEnum | AlumnoScalarFieldEnum[]
  }

  /**
   * alumno create
   */
  export type alumnoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumnoInclude<ExtArgs> | null
    /**
     * The data needed to create a alumno.
     */
    data: XOR<alumnoCreateInput, alumnoUncheckedCreateInput>
  }

  /**
   * alumno createMany
   */
  export type alumnoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alumnos.
     */
    data: alumnoCreateManyInput | alumnoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * alumno createManyAndReturn
   */
  export type alumnoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many alumnos.
     */
    data: alumnoCreateManyInput | alumnoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * alumno update
   */
  export type alumnoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumnoInclude<ExtArgs> | null
    /**
     * The data needed to update a alumno.
     */
    data: XOR<alumnoUpdateInput, alumnoUncheckedUpdateInput>
    /**
     * Choose, which alumno to update.
     */
    where: alumnoWhereUniqueInput
  }

  /**
   * alumno updateMany
   */
  export type alumnoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alumnos.
     */
    data: XOR<alumnoUpdateManyMutationInput, alumnoUncheckedUpdateManyInput>
    /**
     * Filter which alumnos to update
     */
    where?: alumnoWhereInput
  }

  /**
   * alumno upsert
   */
  export type alumnoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumnoInclude<ExtArgs> | null
    /**
     * The filter to search for the alumno to update in case it exists.
     */
    where: alumnoWhereUniqueInput
    /**
     * In case the alumno found by the `where` argument doesn't exist, create a new alumno with this data.
     */
    create: XOR<alumnoCreateInput, alumnoUncheckedCreateInput>
    /**
     * In case the alumno was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alumnoUpdateInput, alumnoUncheckedUpdateInput>
  }

  /**
   * alumno delete
   */
  export type alumnoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumnoInclude<ExtArgs> | null
    /**
     * Filter which alumno to delete.
     */
    where: alumnoWhereUniqueInput
  }

  /**
   * alumno deleteMany
   */
  export type alumnoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alumnos to delete
     */
    where?: alumnoWhereInput
  }

  /**
   * alumno.inscripciones
   */
  export type alumno$inscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    where?: alumno_tallerWhereInput
    orderBy?: alumno_tallerOrderByWithRelationInput | alumno_tallerOrderByWithRelationInput[]
    cursor?: alumno_tallerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Alumno_tallerScalarFieldEnum | Alumno_tallerScalarFieldEnum[]
  }

  /**
   * alumno.comprobantes
   */
  export type alumno$comprobantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    where?: comprobanteWhereInput
    orderBy?: comprobanteOrderByWithRelationInput | comprobanteOrderByWithRelationInput[]
    cursor?: comprobanteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * alumno without action
   */
  export type alumnoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno
     */
    select?: alumnoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumnoInclude<ExtArgs> | null
  }


  /**
   * Model taller
   */

  export type AggregateTaller = {
    _count: TallerCountAggregateOutputType | null
    _avg: TallerAvgAggregateOutputType | null
    _sum: TallerSumAggregateOutputType | null
    _min: TallerMinAggregateOutputType | null
    _max: TallerMaxAggregateOutputType | null
  }

  export type TallerAvgAggregateOutputType = {
    id_taller: number | null
    id_maestro: number | null
    cupo: number | null
  }

  export type TallerSumAggregateOutputType = {
    id_taller: number | null
    id_maestro: number | null
    cupo: number | null
  }

  export type TallerMinAggregateOutputType = {
    id_taller: number | null
    id_maestro: number | null
    nombre: string | null
    fecha_ini: Date | null
    fecha_fin: Date | null
    horario: string | null
    dias: string | null
    auxiliar: string | null
    cupo: number | null
  }

  export type TallerMaxAggregateOutputType = {
    id_taller: number | null
    id_maestro: number | null
    nombre: string | null
    fecha_ini: Date | null
    fecha_fin: Date | null
    horario: string | null
    dias: string | null
    auxiliar: string | null
    cupo: number | null
  }

  export type TallerCountAggregateOutputType = {
    id_taller: number
    id_maestro: number
    nombre: number
    fecha_ini: number
    fecha_fin: number
    horario: number
    dias: number
    auxiliar: number
    cupo: number
    _all: number
  }


  export type TallerAvgAggregateInputType = {
    id_taller?: true
    id_maestro?: true
    cupo?: true
  }

  export type TallerSumAggregateInputType = {
    id_taller?: true
    id_maestro?: true
    cupo?: true
  }

  export type TallerMinAggregateInputType = {
    id_taller?: true
    id_maestro?: true
    nombre?: true
    fecha_ini?: true
    fecha_fin?: true
    horario?: true
    dias?: true
    auxiliar?: true
    cupo?: true
  }

  export type TallerMaxAggregateInputType = {
    id_taller?: true
    id_maestro?: true
    nombre?: true
    fecha_ini?: true
    fecha_fin?: true
    horario?: true
    dias?: true
    auxiliar?: true
    cupo?: true
  }

  export type TallerCountAggregateInputType = {
    id_taller?: true
    id_maestro?: true
    nombre?: true
    fecha_ini?: true
    fecha_fin?: true
    horario?: true
    dias?: true
    auxiliar?: true
    cupo?: true
    _all?: true
  }

  export type TallerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taller to aggregate.
     */
    where?: tallerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tallers to fetch.
     */
    orderBy?: tallerOrderByWithRelationInput | tallerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tallerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tallers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tallers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tallers
    **/
    _count?: true | TallerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TallerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TallerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TallerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TallerMaxAggregateInputType
  }

  export type GetTallerAggregateType<T extends TallerAggregateArgs> = {
        [P in keyof T & keyof AggregateTaller]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaller[P]>
      : GetScalarType<T[P], AggregateTaller[P]>
  }




  export type tallerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tallerWhereInput
    orderBy?: tallerOrderByWithAggregationInput | tallerOrderByWithAggregationInput[]
    by: TallerScalarFieldEnum[] | TallerScalarFieldEnum
    having?: tallerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TallerCountAggregateInputType | true
    _avg?: TallerAvgAggregateInputType
    _sum?: TallerSumAggregateInputType
    _min?: TallerMinAggregateInputType
    _max?: TallerMaxAggregateInputType
  }

  export type TallerGroupByOutputType = {
    id_taller: number
    id_maestro: number
    nombre: string
    fecha_ini: Date
    fecha_fin: Date | null
    horario: string | null
    dias: string | null
    auxiliar: string | null
    cupo: number
    _count: TallerCountAggregateOutputType | null
    _avg: TallerAvgAggregateOutputType | null
    _sum: TallerSumAggregateOutputType | null
    _min: TallerMinAggregateOutputType | null
    _max: TallerMaxAggregateOutputType | null
  }

  type GetTallerGroupByPayload<T extends tallerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TallerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TallerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TallerGroupByOutputType[P]>
            : GetScalarType<T[P], TallerGroupByOutputType[P]>
        }
      >
    >


  export type tallerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_taller?: boolean
    id_maestro?: boolean
    nombre?: boolean
    fecha_ini?: boolean
    fecha_fin?: boolean
    horario?: boolean
    dias?: boolean
    auxiliar?: boolean
    cupo?: boolean
    maestro?: boolean | maestroDefaultArgs<ExtArgs>
    alumnos?: boolean | taller$alumnosArgs<ExtArgs>
    comprobantes?: boolean | taller$comprobantesArgs<ExtArgs>
    _count?: boolean | TallerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taller"]>

  export type tallerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_taller?: boolean
    id_maestro?: boolean
    nombre?: boolean
    fecha_ini?: boolean
    fecha_fin?: boolean
    horario?: boolean
    dias?: boolean
    auxiliar?: boolean
    cupo?: boolean
    maestro?: boolean | maestroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taller"]>

  export type tallerSelectScalar = {
    id_taller?: boolean
    id_maestro?: boolean
    nombre?: boolean
    fecha_ini?: boolean
    fecha_fin?: boolean
    horario?: boolean
    dias?: boolean
    auxiliar?: boolean
    cupo?: boolean
  }

  export type tallerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maestro?: boolean | maestroDefaultArgs<ExtArgs>
    alumnos?: boolean | taller$alumnosArgs<ExtArgs>
    comprobantes?: boolean | taller$comprobantesArgs<ExtArgs>
    _count?: boolean | TallerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tallerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maestro?: boolean | maestroDefaultArgs<ExtArgs>
  }

  export type $tallerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "taller"
    objects: {
      maestro: Prisma.$maestroPayload<ExtArgs>
      alumnos: Prisma.$alumno_tallerPayload<ExtArgs>[]
      comprobantes: Prisma.$comprobantePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_taller: number
      id_maestro: number
      nombre: string
      fecha_ini: Date
      fecha_fin: Date | null
      horario: string | null
      dias: string | null
      auxiliar: string | null
      cupo: number
    }, ExtArgs["result"]["taller"]>
    composites: {}
  }

  type tallerGetPayload<S extends boolean | null | undefined | tallerDefaultArgs> = $Result.GetResult<Prisma.$tallerPayload, S>

  type tallerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tallerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TallerCountAggregateInputType | true
    }

  export interface tallerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['taller'], meta: { name: 'taller' } }
    /**
     * Find zero or one Taller that matches the filter.
     * @param {tallerFindUniqueArgs} args - Arguments to find a Taller
     * @example
     * // Get one Taller
     * const taller = await prisma.taller.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tallerFindUniqueArgs>(args: SelectSubset<T, tallerFindUniqueArgs<ExtArgs>>): Prisma__tallerClient<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Taller that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tallerFindUniqueOrThrowArgs} args - Arguments to find a Taller
     * @example
     * // Get one Taller
     * const taller = await prisma.taller.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tallerFindUniqueOrThrowArgs>(args: SelectSubset<T, tallerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tallerClient<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Taller that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tallerFindFirstArgs} args - Arguments to find a Taller
     * @example
     * // Get one Taller
     * const taller = await prisma.taller.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tallerFindFirstArgs>(args?: SelectSubset<T, tallerFindFirstArgs<ExtArgs>>): Prisma__tallerClient<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Taller that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tallerFindFirstOrThrowArgs} args - Arguments to find a Taller
     * @example
     * // Get one Taller
     * const taller = await prisma.taller.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tallerFindFirstOrThrowArgs>(args?: SelectSubset<T, tallerFindFirstOrThrowArgs<ExtArgs>>): Prisma__tallerClient<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tallers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tallerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tallers
     * const tallers = await prisma.taller.findMany()
     * 
     * // Get first 10 Tallers
     * const tallers = await prisma.taller.findMany({ take: 10 })
     * 
     * // Only select the `id_taller`
     * const tallerWithId_tallerOnly = await prisma.taller.findMany({ select: { id_taller: true } })
     * 
     */
    findMany<T extends tallerFindManyArgs>(args?: SelectSubset<T, tallerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Taller.
     * @param {tallerCreateArgs} args - Arguments to create a Taller.
     * @example
     * // Create one Taller
     * const Taller = await prisma.taller.create({
     *   data: {
     *     // ... data to create a Taller
     *   }
     * })
     * 
     */
    create<T extends tallerCreateArgs>(args: SelectSubset<T, tallerCreateArgs<ExtArgs>>): Prisma__tallerClient<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tallers.
     * @param {tallerCreateManyArgs} args - Arguments to create many Tallers.
     * @example
     * // Create many Tallers
     * const taller = await prisma.taller.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tallerCreateManyArgs>(args?: SelectSubset<T, tallerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tallers and returns the data saved in the database.
     * @param {tallerCreateManyAndReturnArgs} args - Arguments to create many Tallers.
     * @example
     * // Create many Tallers
     * const taller = await prisma.taller.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tallers and only return the `id_taller`
     * const tallerWithId_tallerOnly = await prisma.taller.createManyAndReturn({ 
     *   select: { id_taller: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tallerCreateManyAndReturnArgs>(args?: SelectSubset<T, tallerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Taller.
     * @param {tallerDeleteArgs} args - Arguments to delete one Taller.
     * @example
     * // Delete one Taller
     * const Taller = await prisma.taller.delete({
     *   where: {
     *     // ... filter to delete one Taller
     *   }
     * })
     * 
     */
    delete<T extends tallerDeleteArgs>(args: SelectSubset<T, tallerDeleteArgs<ExtArgs>>): Prisma__tallerClient<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Taller.
     * @param {tallerUpdateArgs} args - Arguments to update one Taller.
     * @example
     * // Update one Taller
     * const taller = await prisma.taller.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tallerUpdateArgs>(args: SelectSubset<T, tallerUpdateArgs<ExtArgs>>): Prisma__tallerClient<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tallers.
     * @param {tallerDeleteManyArgs} args - Arguments to filter Tallers to delete.
     * @example
     * // Delete a few Tallers
     * const { count } = await prisma.taller.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tallerDeleteManyArgs>(args?: SelectSubset<T, tallerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tallers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tallerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tallers
     * const taller = await prisma.taller.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tallerUpdateManyArgs>(args: SelectSubset<T, tallerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Taller.
     * @param {tallerUpsertArgs} args - Arguments to update or create a Taller.
     * @example
     * // Update or create a Taller
     * const taller = await prisma.taller.upsert({
     *   create: {
     *     // ... data to create a Taller
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Taller we want to update
     *   }
     * })
     */
    upsert<T extends tallerUpsertArgs>(args: SelectSubset<T, tallerUpsertArgs<ExtArgs>>): Prisma__tallerClient<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tallers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tallerCountArgs} args - Arguments to filter Tallers to count.
     * @example
     * // Count the number of Tallers
     * const count = await prisma.taller.count({
     *   where: {
     *     // ... the filter for the Tallers we want to count
     *   }
     * })
    **/
    count<T extends tallerCountArgs>(
      args?: Subset<T, tallerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TallerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Taller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TallerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TallerAggregateArgs>(args: Subset<T, TallerAggregateArgs>): Prisma.PrismaPromise<GetTallerAggregateType<T>>

    /**
     * Group by Taller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tallerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tallerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tallerGroupByArgs['orderBy'] }
        : { orderBy?: tallerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tallerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTallerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the taller model
   */
  readonly fields: tallerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for taller.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tallerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maestro<T extends maestroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, maestroDefaultArgs<ExtArgs>>): Prisma__maestroClient<$Result.GetResult<Prisma.$maestroPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    alumnos<T extends taller$alumnosArgs<ExtArgs> = {}>(args?: Subset<T, taller$alumnosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "findMany"> | Null>
    comprobantes<T extends taller$comprobantesArgs<ExtArgs> = {}>(args?: Subset<T, taller$comprobantesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the taller model
   */ 
  interface tallerFieldRefs {
    readonly id_taller: FieldRef<"taller", 'Int'>
    readonly id_maestro: FieldRef<"taller", 'Int'>
    readonly nombre: FieldRef<"taller", 'String'>
    readonly fecha_ini: FieldRef<"taller", 'DateTime'>
    readonly fecha_fin: FieldRef<"taller", 'DateTime'>
    readonly horario: FieldRef<"taller", 'String'>
    readonly dias: FieldRef<"taller", 'String'>
    readonly auxiliar: FieldRef<"taller", 'String'>
    readonly cupo: FieldRef<"taller", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * taller findUnique
   */
  export type tallerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    /**
     * Filter, which taller to fetch.
     */
    where: tallerWhereUniqueInput
  }

  /**
   * taller findUniqueOrThrow
   */
  export type tallerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    /**
     * Filter, which taller to fetch.
     */
    where: tallerWhereUniqueInput
  }

  /**
   * taller findFirst
   */
  export type tallerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    /**
     * Filter, which taller to fetch.
     */
    where?: tallerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tallers to fetch.
     */
    orderBy?: tallerOrderByWithRelationInput | tallerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tallers.
     */
    cursor?: tallerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tallers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tallers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tallers.
     */
    distinct?: TallerScalarFieldEnum | TallerScalarFieldEnum[]
  }

  /**
   * taller findFirstOrThrow
   */
  export type tallerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    /**
     * Filter, which taller to fetch.
     */
    where?: tallerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tallers to fetch.
     */
    orderBy?: tallerOrderByWithRelationInput | tallerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tallers.
     */
    cursor?: tallerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tallers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tallers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tallers.
     */
    distinct?: TallerScalarFieldEnum | TallerScalarFieldEnum[]
  }

  /**
   * taller findMany
   */
  export type tallerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    /**
     * Filter, which tallers to fetch.
     */
    where?: tallerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tallers to fetch.
     */
    orderBy?: tallerOrderByWithRelationInput | tallerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tallers.
     */
    cursor?: tallerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tallers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tallers.
     */
    skip?: number
    distinct?: TallerScalarFieldEnum | TallerScalarFieldEnum[]
  }

  /**
   * taller create
   */
  export type tallerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    /**
     * The data needed to create a taller.
     */
    data: XOR<tallerCreateInput, tallerUncheckedCreateInput>
  }

  /**
   * taller createMany
   */
  export type tallerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tallers.
     */
    data: tallerCreateManyInput | tallerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * taller createManyAndReturn
   */
  export type tallerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tallers.
     */
    data: tallerCreateManyInput | tallerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * taller update
   */
  export type tallerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    /**
     * The data needed to update a taller.
     */
    data: XOR<tallerUpdateInput, tallerUncheckedUpdateInput>
    /**
     * Choose, which taller to update.
     */
    where: tallerWhereUniqueInput
  }

  /**
   * taller updateMany
   */
  export type tallerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tallers.
     */
    data: XOR<tallerUpdateManyMutationInput, tallerUncheckedUpdateManyInput>
    /**
     * Filter which tallers to update
     */
    where?: tallerWhereInput
  }

  /**
   * taller upsert
   */
  export type tallerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    /**
     * The filter to search for the taller to update in case it exists.
     */
    where: tallerWhereUniqueInput
    /**
     * In case the taller found by the `where` argument doesn't exist, create a new taller with this data.
     */
    create: XOR<tallerCreateInput, tallerUncheckedCreateInput>
    /**
     * In case the taller was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tallerUpdateInput, tallerUncheckedUpdateInput>
  }

  /**
   * taller delete
   */
  export type tallerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    /**
     * Filter which taller to delete.
     */
    where: tallerWhereUniqueInput
  }

  /**
   * taller deleteMany
   */
  export type tallerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tallers to delete
     */
    where?: tallerWhereInput
  }

  /**
   * taller.alumnos
   */
  export type taller$alumnosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    where?: alumno_tallerWhereInput
    orderBy?: alumno_tallerOrderByWithRelationInput | alumno_tallerOrderByWithRelationInput[]
    cursor?: alumno_tallerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Alumno_tallerScalarFieldEnum | Alumno_tallerScalarFieldEnum[]
  }

  /**
   * taller.comprobantes
   */
  export type taller$comprobantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    where?: comprobanteWhereInput
    orderBy?: comprobanteOrderByWithRelationInput | comprobanteOrderByWithRelationInput[]
    cursor?: comprobanteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * taller without action
   */
  export type tallerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
  }


  /**
   * Model alumno_taller
   */

  export type AggregateAlumno_taller = {
    _count: Alumno_tallerCountAggregateOutputType | null
    _avg: Alumno_tallerAvgAggregateOutputType | null
    _sum: Alumno_tallerSumAggregateOutputType | null
    _min: Alumno_tallerMinAggregateOutputType | null
    _max: Alumno_tallerMaxAggregateOutputType | null
  }

  export type Alumno_tallerAvgAggregateOutputType = {
    id: number | null
    id_alumno: number | null
    id_taller: number | null
    horas_asignadas: number | null
  }

  export type Alumno_tallerSumAggregateOutputType = {
    id: number | null
    id_alumno: number | null
    id_taller: number | null
    horas_asignadas: number | null
  }

  export type Alumno_tallerMinAggregateOutputType = {
    id: number | null
    id_alumno: number | null
    id_taller: number | null
    fecha_inscripcion: Date | null
    horas_asignadas: number | null
  }

  export type Alumno_tallerMaxAggregateOutputType = {
    id: number | null
    id_alumno: number | null
    id_taller: number | null
    fecha_inscripcion: Date | null
    horas_asignadas: number | null
  }

  export type Alumno_tallerCountAggregateOutputType = {
    id: number
    id_alumno: number
    id_taller: number
    fecha_inscripcion: number
    horas_asignadas: number
    _all: number
  }


  export type Alumno_tallerAvgAggregateInputType = {
    id?: true
    id_alumno?: true
    id_taller?: true
    horas_asignadas?: true
  }

  export type Alumno_tallerSumAggregateInputType = {
    id?: true
    id_alumno?: true
    id_taller?: true
    horas_asignadas?: true
  }

  export type Alumno_tallerMinAggregateInputType = {
    id?: true
    id_alumno?: true
    id_taller?: true
    fecha_inscripcion?: true
    horas_asignadas?: true
  }

  export type Alumno_tallerMaxAggregateInputType = {
    id?: true
    id_alumno?: true
    id_taller?: true
    fecha_inscripcion?: true
    horas_asignadas?: true
  }

  export type Alumno_tallerCountAggregateInputType = {
    id?: true
    id_alumno?: true
    id_taller?: true
    fecha_inscripcion?: true
    horas_asignadas?: true
    _all?: true
  }

  export type Alumno_tallerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alumno_taller to aggregate.
     */
    where?: alumno_tallerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumno_tallers to fetch.
     */
    orderBy?: alumno_tallerOrderByWithRelationInput | alumno_tallerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alumno_tallerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumno_tallers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumno_tallers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alumno_tallers
    **/
    _count?: true | Alumno_tallerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Alumno_tallerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Alumno_tallerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Alumno_tallerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Alumno_tallerMaxAggregateInputType
  }

  export type GetAlumno_tallerAggregateType<T extends Alumno_tallerAggregateArgs> = {
        [P in keyof T & keyof AggregateAlumno_taller]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlumno_taller[P]>
      : GetScalarType<T[P], AggregateAlumno_taller[P]>
  }




  export type alumno_tallerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alumno_tallerWhereInput
    orderBy?: alumno_tallerOrderByWithAggregationInput | alumno_tallerOrderByWithAggregationInput[]
    by: Alumno_tallerScalarFieldEnum[] | Alumno_tallerScalarFieldEnum
    having?: alumno_tallerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Alumno_tallerCountAggregateInputType | true
    _avg?: Alumno_tallerAvgAggregateInputType
    _sum?: Alumno_tallerSumAggregateInputType
    _min?: Alumno_tallerMinAggregateInputType
    _max?: Alumno_tallerMaxAggregateInputType
  }

  export type Alumno_tallerGroupByOutputType = {
    id: number
    id_alumno: number
    id_taller: number
    fecha_inscripcion: Date
    horas_asignadas: number
    _count: Alumno_tallerCountAggregateOutputType | null
    _avg: Alumno_tallerAvgAggregateOutputType | null
    _sum: Alumno_tallerSumAggregateOutputType | null
    _min: Alumno_tallerMinAggregateOutputType | null
    _max: Alumno_tallerMaxAggregateOutputType | null
  }

  type GetAlumno_tallerGroupByPayload<T extends alumno_tallerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Alumno_tallerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Alumno_tallerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Alumno_tallerGroupByOutputType[P]>
            : GetScalarType<T[P], Alumno_tallerGroupByOutputType[P]>
        }
      >
    >


  export type alumno_tallerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_alumno?: boolean
    id_taller?: boolean
    fecha_inscripcion?: boolean
    horas_asignadas?: boolean
    alumno?: boolean | alumnoDefaultArgs<ExtArgs>
    taller?: boolean | tallerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alumno_taller"]>

  export type alumno_tallerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_alumno?: boolean
    id_taller?: boolean
    fecha_inscripcion?: boolean
    horas_asignadas?: boolean
    alumno?: boolean | alumnoDefaultArgs<ExtArgs>
    taller?: boolean | tallerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alumno_taller"]>

  export type alumno_tallerSelectScalar = {
    id?: boolean
    id_alumno?: boolean
    id_taller?: boolean
    fecha_inscripcion?: boolean
    horas_asignadas?: boolean
  }

  export type alumno_tallerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | alumnoDefaultArgs<ExtArgs>
    taller?: boolean | tallerDefaultArgs<ExtArgs>
  }
  export type alumno_tallerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | alumnoDefaultArgs<ExtArgs>
    taller?: boolean | tallerDefaultArgs<ExtArgs>
  }

  export type $alumno_tallerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "alumno_taller"
    objects: {
      alumno: Prisma.$alumnoPayload<ExtArgs>
      taller: Prisma.$tallerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_alumno: number
      id_taller: number
      fecha_inscripcion: Date
      horas_asignadas: number
    }, ExtArgs["result"]["alumno_taller"]>
    composites: {}
  }

  type alumno_tallerGetPayload<S extends boolean | null | undefined | alumno_tallerDefaultArgs> = $Result.GetResult<Prisma.$alumno_tallerPayload, S>

  type alumno_tallerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<alumno_tallerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Alumno_tallerCountAggregateInputType | true
    }

  export interface alumno_tallerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['alumno_taller'], meta: { name: 'alumno_taller' } }
    /**
     * Find zero or one Alumno_taller that matches the filter.
     * @param {alumno_tallerFindUniqueArgs} args - Arguments to find a Alumno_taller
     * @example
     * // Get one Alumno_taller
     * const alumno_taller = await prisma.alumno_taller.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends alumno_tallerFindUniqueArgs>(args: SelectSubset<T, alumno_tallerFindUniqueArgs<ExtArgs>>): Prisma__alumno_tallerClient<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alumno_taller that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {alumno_tallerFindUniqueOrThrowArgs} args - Arguments to find a Alumno_taller
     * @example
     * // Get one Alumno_taller
     * const alumno_taller = await prisma.alumno_taller.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends alumno_tallerFindUniqueOrThrowArgs>(args: SelectSubset<T, alumno_tallerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__alumno_tallerClient<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alumno_taller that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumno_tallerFindFirstArgs} args - Arguments to find a Alumno_taller
     * @example
     * // Get one Alumno_taller
     * const alumno_taller = await prisma.alumno_taller.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends alumno_tallerFindFirstArgs>(args?: SelectSubset<T, alumno_tallerFindFirstArgs<ExtArgs>>): Prisma__alumno_tallerClient<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alumno_taller that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumno_tallerFindFirstOrThrowArgs} args - Arguments to find a Alumno_taller
     * @example
     * // Get one Alumno_taller
     * const alumno_taller = await prisma.alumno_taller.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends alumno_tallerFindFirstOrThrowArgs>(args?: SelectSubset<T, alumno_tallerFindFirstOrThrowArgs<ExtArgs>>): Prisma__alumno_tallerClient<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alumno_tallers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumno_tallerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alumno_tallers
     * const alumno_tallers = await prisma.alumno_taller.findMany()
     * 
     * // Get first 10 Alumno_tallers
     * const alumno_tallers = await prisma.alumno_taller.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alumno_tallerWithIdOnly = await prisma.alumno_taller.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends alumno_tallerFindManyArgs>(args?: SelectSubset<T, alumno_tallerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alumno_taller.
     * @param {alumno_tallerCreateArgs} args - Arguments to create a Alumno_taller.
     * @example
     * // Create one Alumno_taller
     * const Alumno_taller = await prisma.alumno_taller.create({
     *   data: {
     *     // ... data to create a Alumno_taller
     *   }
     * })
     * 
     */
    create<T extends alumno_tallerCreateArgs>(args: SelectSubset<T, alumno_tallerCreateArgs<ExtArgs>>): Prisma__alumno_tallerClient<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alumno_tallers.
     * @param {alumno_tallerCreateManyArgs} args - Arguments to create many Alumno_tallers.
     * @example
     * // Create many Alumno_tallers
     * const alumno_taller = await prisma.alumno_taller.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends alumno_tallerCreateManyArgs>(args?: SelectSubset<T, alumno_tallerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alumno_tallers and returns the data saved in the database.
     * @param {alumno_tallerCreateManyAndReturnArgs} args - Arguments to create many Alumno_tallers.
     * @example
     * // Create many Alumno_tallers
     * const alumno_taller = await prisma.alumno_taller.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alumno_tallers and only return the `id`
     * const alumno_tallerWithIdOnly = await prisma.alumno_taller.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends alumno_tallerCreateManyAndReturnArgs>(args?: SelectSubset<T, alumno_tallerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alumno_taller.
     * @param {alumno_tallerDeleteArgs} args - Arguments to delete one Alumno_taller.
     * @example
     * // Delete one Alumno_taller
     * const Alumno_taller = await prisma.alumno_taller.delete({
     *   where: {
     *     // ... filter to delete one Alumno_taller
     *   }
     * })
     * 
     */
    delete<T extends alumno_tallerDeleteArgs>(args: SelectSubset<T, alumno_tallerDeleteArgs<ExtArgs>>): Prisma__alumno_tallerClient<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alumno_taller.
     * @param {alumno_tallerUpdateArgs} args - Arguments to update one Alumno_taller.
     * @example
     * // Update one Alumno_taller
     * const alumno_taller = await prisma.alumno_taller.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends alumno_tallerUpdateArgs>(args: SelectSubset<T, alumno_tallerUpdateArgs<ExtArgs>>): Prisma__alumno_tallerClient<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alumno_tallers.
     * @param {alumno_tallerDeleteManyArgs} args - Arguments to filter Alumno_tallers to delete.
     * @example
     * // Delete a few Alumno_tallers
     * const { count } = await prisma.alumno_taller.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends alumno_tallerDeleteManyArgs>(args?: SelectSubset<T, alumno_tallerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alumno_tallers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumno_tallerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alumno_tallers
     * const alumno_taller = await prisma.alumno_taller.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends alumno_tallerUpdateManyArgs>(args: SelectSubset<T, alumno_tallerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alumno_taller.
     * @param {alumno_tallerUpsertArgs} args - Arguments to update or create a Alumno_taller.
     * @example
     * // Update or create a Alumno_taller
     * const alumno_taller = await prisma.alumno_taller.upsert({
     *   create: {
     *     // ... data to create a Alumno_taller
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alumno_taller we want to update
     *   }
     * })
     */
    upsert<T extends alumno_tallerUpsertArgs>(args: SelectSubset<T, alumno_tallerUpsertArgs<ExtArgs>>): Prisma__alumno_tallerClient<$Result.GetResult<Prisma.$alumno_tallerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alumno_tallers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumno_tallerCountArgs} args - Arguments to filter Alumno_tallers to count.
     * @example
     * // Count the number of Alumno_tallers
     * const count = await prisma.alumno_taller.count({
     *   where: {
     *     // ... the filter for the Alumno_tallers we want to count
     *   }
     * })
    **/
    count<T extends alumno_tallerCountArgs>(
      args?: Subset<T, alumno_tallerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Alumno_tallerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alumno_taller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alumno_tallerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Alumno_tallerAggregateArgs>(args: Subset<T, Alumno_tallerAggregateArgs>): Prisma.PrismaPromise<GetAlumno_tallerAggregateType<T>>

    /**
     * Group by Alumno_taller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alumno_tallerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alumno_tallerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alumno_tallerGroupByArgs['orderBy'] }
        : { orderBy?: alumno_tallerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alumno_tallerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlumno_tallerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the alumno_taller model
   */
  readonly fields: alumno_tallerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for alumno_taller.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__alumno_tallerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alumno<T extends alumnoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, alumnoDefaultArgs<ExtArgs>>): Prisma__alumnoClient<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    taller<T extends tallerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tallerDefaultArgs<ExtArgs>>): Prisma__tallerClient<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the alumno_taller model
   */ 
  interface alumno_tallerFieldRefs {
    readonly id: FieldRef<"alumno_taller", 'Int'>
    readonly id_alumno: FieldRef<"alumno_taller", 'Int'>
    readonly id_taller: FieldRef<"alumno_taller", 'Int'>
    readonly fecha_inscripcion: FieldRef<"alumno_taller", 'DateTime'>
    readonly horas_asignadas: FieldRef<"alumno_taller", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * alumno_taller findUnique
   */
  export type alumno_tallerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    /**
     * Filter, which alumno_taller to fetch.
     */
    where: alumno_tallerWhereUniqueInput
  }

  /**
   * alumno_taller findUniqueOrThrow
   */
  export type alumno_tallerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    /**
     * Filter, which alumno_taller to fetch.
     */
    where: alumno_tallerWhereUniqueInput
  }

  /**
   * alumno_taller findFirst
   */
  export type alumno_tallerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    /**
     * Filter, which alumno_taller to fetch.
     */
    where?: alumno_tallerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumno_tallers to fetch.
     */
    orderBy?: alumno_tallerOrderByWithRelationInput | alumno_tallerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alumno_tallers.
     */
    cursor?: alumno_tallerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumno_tallers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumno_tallers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alumno_tallers.
     */
    distinct?: Alumno_tallerScalarFieldEnum | Alumno_tallerScalarFieldEnum[]
  }

  /**
   * alumno_taller findFirstOrThrow
   */
  export type alumno_tallerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    /**
     * Filter, which alumno_taller to fetch.
     */
    where?: alumno_tallerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumno_tallers to fetch.
     */
    orderBy?: alumno_tallerOrderByWithRelationInput | alumno_tallerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alumno_tallers.
     */
    cursor?: alumno_tallerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumno_tallers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumno_tallers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alumno_tallers.
     */
    distinct?: Alumno_tallerScalarFieldEnum | Alumno_tallerScalarFieldEnum[]
  }

  /**
   * alumno_taller findMany
   */
  export type alumno_tallerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    /**
     * Filter, which alumno_tallers to fetch.
     */
    where?: alumno_tallerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alumno_tallers to fetch.
     */
    orderBy?: alumno_tallerOrderByWithRelationInput | alumno_tallerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alumno_tallers.
     */
    cursor?: alumno_tallerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alumno_tallers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alumno_tallers.
     */
    skip?: number
    distinct?: Alumno_tallerScalarFieldEnum | Alumno_tallerScalarFieldEnum[]
  }

  /**
   * alumno_taller create
   */
  export type alumno_tallerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    /**
     * The data needed to create a alumno_taller.
     */
    data: XOR<alumno_tallerCreateInput, alumno_tallerUncheckedCreateInput>
  }

  /**
   * alumno_taller createMany
   */
  export type alumno_tallerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alumno_tallers.
     */
    data: alumno_tallerCreateManyInput | alumno_tallerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * alumno_taller createManyAndReturn
   */
  export type alumno_tallerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many alumno_tallers.
     */
    data: alumno_tallerCreateManyInput | alumno_tallerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * alumno_taller update
   */
  export type alumno_tallerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    /**
     * The data needed to update a alumno_taller.
     */
    data: XOR<alumno_tallerUpdateInput, alumno_tallerUncheckedUpdateInput>
    /**
     * Choose, which alumno_taller to update.
     */
    where: alumno_tallerWhereUniqueInput
  }

  /**
   * alumno_taller updateMany
   */
  export type alumno_tallerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alumno_tallers.
     */
    data: XOR<alumno_tallerUpdateManyMutationInput, alumno_tallerUncheckedUpdateManyInput>
    /**
     * Filter which alumno_tallers to update
     */
    where?: alumno_tallerWhereInput
  }

  /**
   * alumno_taller upsert
   */
  export type alumno_tallerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    /**
     * The filter to search for the alumno_taller to update in case it exists.
     */
    where: alumno_tallerWhereUniqueInput
    /**
     * In case the alumno_taller found by the `where` argument doesn't exist, create a new alumno_taller with this data.
     */
    create: XOR<alumno_tallerCreateInput, alumno_tallerUncheckedCreateInput>
    /**
     * In case the alumno_taller was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alumno_tallerUpdateInput, alumno_tallerUncheckedUpdateInput>
  }

  /**
   * alumno_taller delete
   */
  export type alumno_tallerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
    /**
     * Filter which alumno_taller to delete.
     */
    where: alumno_tallerWhereUniqueInput
  }

  /**
   * alumno_taller deleteMany
   */
  export type alumno_tallerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alumno_tallers to delete
     */
    where?: alumno_tallerWhereInput
  }

  /**
   * alumno_taller without action
   */
  export type alumno_tallerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alumno_taller
     */
    select?: alumno_tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alumno_tallerInclude<ExtArgs> | null
  }


  /**
   * Model comprobante
   */

  export type AggregateComprobante = {
    _count: ComprobanteCountAggregateOutputType | null
    _avg: ComprobanteAvgAggregateOutputType | null
    _sum: ComprobanteSumAggregateOutputType | null
    _min: ComprobanteMinAggregateOutputType | null
    _max: ComprobanteMaxAggregateOutputType | null
  }

  export type ComprobanteAvgAggregateOutputType = {
    id_comprobante: number | null
    id_alumno: number | null
    id_taller: number | null
    monto: Decimal | null
  }

  export type ComprobanteSumAggregateOutputType = {
    id_comprobante: number | null
    id_alumno: number | null
    id_taller: number | null
    monto: Decimal | null
  }

  export type ComprobanteMinAggregateOutputType = {
    id_comprobante: number | null
    id_alumno: number | null
    id_taller: number | null
    fecha_pago: Date | null
    monto: Decimal | null
    estado: string | null
  }

  export type ComprobanteMaxAggregateOutputType = {
    id_comprobante: number | null
    id_alumno: number | null
    id_taller: number | null
    fecha_pago: Date | null
    monto: Decimal | null
    estado: string | null
  }

  export type ComprobanteCountAggregateOutputType = {
    id_comprobante: number
    id_alumno: number
    id_taller: number
    fecha_pago: number
    monto: number
    estado: number
    _all: number
  }


  export type ComprobanteAvgAggregateInputType = {
    id_comprobante?: true
    id_alumno?: true
    id_taller?: true
    monto?: true
  }

  export type ComprobanteSumAggregateInputType = {
    id_comprobante?: true
    id_alumno?: true
    id_taller?: true
    monto?: true
  }

  export type ComprobanteMinAggregateInputType = {
    id_comprobante?: true
    id_alumno?: true
    id_taller?: true
    fecha_pago?: true
    monto?: true
    estado?: true
  }

  export type ComprobanteMaxAggregateInputType = {
    id_comprobante?: true
    id_alumno?: true
    id_taller?: true
    fecha_pago?: true
    monto?: true
    estado?: true
  }

  export type ComprobanteCountAggregateInputType = {
    id_comprobante?: true
    id_alumno?: true
    id_taller?: true
    fecha_pago?: true
    monto?: true
    estado?: true
    _all?: true
  }

  export type ComprobanteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comprobante to aggregate.
     */
    where?: comprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comprobantes to fetch.
     */
    orderBy?: comprobanteOrderByWithRelationInput | comprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comprobantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comprobantes
    **/
    _count?: true | ComprobanteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComprobanteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComprobanteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComprobanteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComprobanteMaxAggregateInputType
  }

  export type GetComprobanteAggregateType<T extends ComprobanteAggregateArgs> = {
        [P in keyof T & keyof AggregateComprobante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComprobante[P]>
      : GetScalarType<T[P], AggregateComprobante[P]>
  }




  export type comprobanteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprobanteWhereInput
    orderBy?: comprobanteOrderByWithAggregationInput | comprobanteOrderByWithAggregationInput[]
    by: ComprobanteScalarFieldEnum[] | ComprobanteScalarFieldEnum
    having?: comprobanteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComprobanteCountAggregateInputType | true
    _avg?: ComprobanteAvgAggregateInputType
    _sum?: ComprobanteSumAggregateInputType
    _min?: ComprobanteMinAggregateInputType
    _max?: ComprobanteMaxAggregateInputType
  }

  export type ComprobanteGroupByOutputType = {
    id_comprobante: number
    id_alumno: number
    id_taller: number | null
    fecha_pago: Date
    monto: Decimal
    estado: string
    _count: ComprobanteCountAggregateOutputType | null
    _avg: ComprobanteAvgAggregateOutputType | null
    _sum: ComprobanteSumAggregateOutputType | null
    _min: ComprobanteMinAggregateOutputType | null
    _max: ComprobanteMaxAggregateOutputType | null
  }

  type GetComprobanteGroupByPayload<T extends comprobanteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComprobanteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComprobanteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComprobanteGroupByOutputType[P]>
            : GetScalarType<T[P], ComprobanteGroupByOutputType[P]>
        }
      >
    >


  export type comprobanteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_comprobante?: boolean
    id_alumno?: boolean
    id_taller?: boolean
    fecha_pago?: boolean
    monto?: boolean
    estado?: boolean
    alumno?: boolean | alumnoDefaultArgs<ExtArgs>
    taller?: boolean | comprobante$tallerArgs<ExtArgs>
  }, ExtArgs["result"]["comprobante"]>

  export type comprobanteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_comprobante?: boolean
    id_alumno?: boolean
    id_taller?: boolean
    fecha_pago?: boolean
    monto?: boolean
    estado?: boolean
    alumno?: boolean | alumnoDefaultArgs<ExtArgs>
    taller?: boolean | comprobante$tallerArgs<ExtArgs>
  }, ExtArgs["result"]["comprobante"]>

  export type comprobanteSelectScalar = {
    id_comprobante?: boolean
    id_alumno?: boolean
    id_taller?: boolean
    fecha_pago?: boolean
    monto?: boolean
    estado?: boolean
  }

  export type comprobanteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | alumnoDefaultArgs<ExtArgs>
    taller?: boolean | comprobante$tallerArgs<ExtArgs>
  }
  export type comprobanteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alumno?: boolean | alumnoDefaultArgs<ExtArgs>
    taller?: boolean | comprobante$tallerArgs<ExtArgs>
  }

  export type $comprobantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comprobante"
    objects: {
      alumno: Prisma.$alumnoPayload<ExtArgs>
      taller: Prisma.$tallerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_comprobante: number
      id_alumno: number
      id_taller: number | null
      fecha_pago: Date
      monto: Prisma.Decimal
      estado: string
    }, ExtArgs["result"]["comprobante"]>
    composites: {}
  }

  type comprobanteGetPayload<S extends boolean | null | undefined | comprobanteDefaultArgs> = $Result.GetResult<Prisma.$comprobantePayload, S>

  type comprobanteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<comprobanteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComprobanteCountAggregateInputType | true
    }

  export interface comprobanteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comprobante'], meta: { name: 'comprobante' } }
    /**
     * Find zero or one Comprobante that matches the filter.
     * @param {comprobanteFindUniqueArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comprobanteFindUniqueArgs>(args: SelectSubset<T, comprobanteFindUniqueArgs<ExtArgs>>): Prisma__comprobanteClient<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comprobante that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {comprobanteFindUniqueOrThrowArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comprobanteFindUniqueOrThrowArgs>(args: SelectSubset<T, comprobanteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comprobanteClient<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comprobante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprobanteFindFirstArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comprobanteFindFirstArgs>(args?: SelectSubset<T, comprobanteFindFirstArgs<ExtArgs>>): Prisma__comprobanteClient<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comprobante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprobanteFindFirstOrThrowArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comprobanteFindFirstOrThrowArgs>(args?: SelectSubset<T, comprobanteFindFirstOrThrowArgs<ExtArgs>>): Prisma__comprobanteClient<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comprobantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprobanteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comprobantes
     * const comprobantes = await prisma.comprobante.findMany()
     * 
     * // Get first 10 Comprobantes
     * const comprobantes = await prisma.comprobante.findMany({ take: 10 })
     * 
     * // Only select the `id_comprobante`
     * const comprobanteWithId_comprobanteOnly = await prisma.comprobante.findMany({ select: { id_comprobante: true } })
     * 
     */
    findMany<T extends comprobanteFindManyArgs>(args?: SelectSubset<T, comprobanteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comprobante.
     * @param {comprobanteCreateArgs} args - Arguments to create a Comprobante.
     * @example
     * // Create one Comprobante
     * const Comprobante = await prisma.comprobante.create({
     *   data: {
     *     // ... data to create a Comprobante
     *   }
     * })
     * 
     */
    create<T extends comprobanteCreateArgs>(args: SelectSubset<T, comprobanteCreateArgs<ExtArgs>>): Prisma__comprobanteClient<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comprobantes.
     * @param {comprobanteCreateManyArgs} args - Arguments to create many Comprobantes.
     * @example
     * // Create many Comprobantes
     * const comprobante = await prisma.comprobante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comprobanteCreateManyArgs>(args?: SelectSubset<T, comprobanteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comprobantes and returns the data saved in the database.
     * @param {comprobanteCreateManyAndReturnArgs} args - Arguments to create many Comprobantes.
     * @example
     * // Create many Comprobantes
     * const comprobante = await prisma.comprobante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comprobantes and only return the `id_comprobante`
     * const comprobanteWithId_comprobanteOnly = await prisma.comprobante.createManyAndReturn({ 
     *   select: { id_comprobante: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends comprobanteCreateManyAndReturnArgs>(args?: SelectSubset<T, comprobanteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comprobante.
     * @param {comprobanteDeleteArgs} args - Arguments to delete one Comprobante.
     * @example
     * // Delete one Comprobante
     * const Comprobante = await prisma.comprobante.delete({
     *   where: {
     *     // ... filter to delete one Comprobante
     *   }
     * })
     * 
     */
    delete<T extends comprobanteDeleteArgs>(args: SelectSubset<T, comprobanteDeleteArgs<ExtArgs>>): Prisma__comprobanteClient<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comprobante.
     * @param {comprobanteUpdateArgs} args - Arguments to update one Comprobante.
     * @example
     * // Update one Comprobante
     * const comprobante = await prisma.comprobante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comprobanteUpdateArgs>(args: SelectSubset<T, comprobanteUpdateArgs<ExtArgs>>): Prisma__comprobanteClient<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comprobantes.
     * @param {comprobanteDeleteManyArgs} args - Arguments to filter Comprobantes to delete.
     * @example
     * // Delete a few Comprobantes
     * const { count } = await prisma.comprobante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comprobanteDeleteManyArgs>(args?: SelectSubset<T, comprobanteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comprobantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprobanteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comprobantes
     * const comprobante = await prisma.comprobante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comprobanteUpdateManyArgs>(args: SelectSubset<T, comprobanteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comprobante.
     * @param {comprobanteUpsertArgs} args - Arguments to update or create a Comprobante.
     * @example
     * // Update or create a Comprobante
     * const comprobante = await prisma.comprobante.upsert({
     *   create: {
     *     // ... data to create a Comprobante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comprobante we want to update
     *   }
     * })
     */
    upsert<T extends comprobanteUpsertArgs>(args: SelectSubset<T, comprobanteUpsertArgs<ExtArgs>>): Prisma__comprobanteClient<$Result.GetResult<Prisma.$comprobantePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comprobantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprobanteCountArgs} args - Arguments to filter Comprobantes to count.
     * @example
     * // Count the number of Comprobantes
     * const count = await prisma.comprobante.count({
     *   where: {
     *     // ... the filter for the Comprobantes we want to count
     *   }
     * })
    **/
    count<T extends comprobanteCountArgs>(
      args?: Subset<T, comprobanteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComprobanteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comprobante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComprobanteAggregateArgs>(args: Subset<T, ComprobanteAggregateArgs>): Prisma.PrismaPromise<GetComprobanteAggregateType<T>>

    /**
     * Group by Comprobante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprobanteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comprobanteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comprobanteGroupByArgs['orderBy'] }
        : { orderBy?: comprobanteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comprobanteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComprobanteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comprobante model
   */
  readonly fields: comprobanteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comprobante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comprobanteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alumno<T extends alumnoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, alumnoDefaultArgs<ExtArgs>>): Prisma__alumnoClient<$Result.GetResult<Prisma.$alumnoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    taller<T extends comprobante$tallerArgs<ExtArgs> = {}>(args?: Subset<T, comprobante$tallerArgs<ExtArgs>>): Prisma__tallerClient<$Result.GetResult<Prisma.$tallerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comprobante model
   */ 
  interface comprobanteFieldRefs {
    readonly id_comprobante: FieldRef<"comprobante", 'Int'>
    readonly id_alumno: FieldRef<"comprobante", 'Int'>
    readonly id_taller: FieldRef<"comprobante", 'Int'>
    readonly fecha_pago: FieldRef<"comprobante", 'DateTime'>
    readonly monto: FieldRef<"comprobante", 'Decimal'>
    readonly estado: FieldRef<"comprobante", 'String'>
  }
    

  // Custom InputTypes
  /**
   * comprobante findUnique
   */
  export type comprobanteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    /**
     * Filter, which comprobante to fetch.
     */
    where: comprobanteWhereUniqueInput
  }

  /**
   * comprobante findUniqueOrThrow
   */
  export type comprobanteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    /**
     * Filter, which comprobante to fetch.
     */
    where: comprobanteWhereUniqueInput
  }

  /**
   * comprobante findFirst
   */
  export type comprobanteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    /**
     * Filter, which comprobante to fetch.
     */
    where?: comprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comprobantes to fetch.
     */
    orderBy?: comprobanteOrderByWithRelationInput | comprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comprobantes.
     */
    cursor?: comprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comprobantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comprobantes.
     */
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * comprobante findFirstOrThrow
   */
  export type comprobanteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    /**
     * Filter, which comprobante to fetch.
     */
    where?: comprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comprobantes to fetch.
     */
    orderBy?: comprobanteOrderByWithRelationInput | comprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comprobantes.
     */
    cursor?: comprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comprobantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comprobantes.
     */
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * comprobante findMany
   */
  export type comprobanteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    /**
     * Filter, which comprobantes to fetch.
     */
    where?: comprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comprobantes to fetch.
     */
    orderBy?: comprobanteOrderByWithRelationInput | comprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comprobantes.
     */
    cursor?: comprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comprobantes.
     */
    skip?: number
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * comprobante create
   */
  export type comprobanteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    /**
     * The data needed to create a comprobante.
     */
    data: XOR<comprobanteCreateInput, comprobanteUncheckedCreateInput>
  }

  /**
   * comprobante createMany
   */
  export type comprobanteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comprobantes.
     */
    data: comprobanteCreateManyInput | comprobanteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comprobante createManyAndReturn
   */
  export type comprobanteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many comprobantes.
     */
    data: comprobanteCreateManyInput | comprobanteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comprobante update
   */
  export type comprobanteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    /**
     * The data needed to update a comprobante.
     */
    data: XOR<comprobanteUpdateInput, comprobanteUncheckedUpdateInput>
    /**
     * Choose, which comprobante to update.
     */
    where: comprobanteWhereUniqueInput
  }

  /**
   * comprobante updateMany
   */
  export type comprobanteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comprobantes.
     */
    data: XOR<comprobanteUpdateManyMutationInput, comprobanteUncheckedUpdateManyInput>
    /**
     * Filter which comprobantes to update
     */
    where?: comprobanteWhereInput
  }

  /**
   * comprobante upsert
   */
  export type comprobanteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    /**
     * The filter to search for the comprobante to update in case it exists.
     */
    where: comprobanteWhereUniqueInput
    /**
     * In case the comprobante found by the `where` argument doesn't exist, create a new comprobante with this data.
     */
    create: XOR<comprobanteCreateInput, comprobanteUncheckedCreateInput>
    /**
     * In case the comprobante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comprobanteUpdateInput, comprobanteUncheckedUpdateInput>
  }

  /**
   * comprobante delete
   */
  export type comprobanteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
    /**
     * Filter which comprobante to delete.
     */
    where: comprobanteWhereUniqueInput
  }

  /**
   * comprobante deleteMany
   */
  export type comprobanteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comprobantes to delete
     */
    where?: comprobanteWhereInput
  }

  /**
   * comprobante.taller
   */
  export type comprobante$tallerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taller
     */
    select?: tallerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tallerInclude<ExtArgs> | null
    where?: tallerWhereInput
  }

  /**
   * comprobante without action
   */
  export type comprobanteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comprobante
     */
    select?: comprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprobanteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MaestroScalarFieldEnum: {
    id_maestro: 'id_maestro',
    nombre: 'nombre',
    apellido: 'apellido',
    dni: 'dni',
    telefono: 'telefono',
    cant_talleres: 'cant_talleres'
  };

  export type MaestroScalarFieldEnum = (typeof MaestroScalarFieldEnum)[keyof typeof MaestroScalarFieldEnum]


  export const AlumnoScalarFieldEnum: {
    id_alumno: 'id_alumno',
    nombre: 'nombre',
    apellido: 'apellido',
    dni: 'dni',
    direccion: 'direccion',
    telefono_madre: 'telefono_madre',
    telefono_padre: 'telefono_padre'
  };

  export type AlumnoScalarFieldEnum = (typeof AlumnoScalarFieldEnum)[keyof typeof AlumnoScalarFieldEnum]


  export const TallerScalarFieldEnum: {
    id_taller: 'id_taller',
    id_maestro: 'id_maestro',
    nombre: 'nombre',
    fecha_ini: 'fecha_ini',
    fecha_fin: 'fecha_fin',
    horario: 'horario',
    dias: 'dias',
    auxiliar: 'auxiliar',
    cupo: 'cupo'
  };

  export type TallerScalarFieldEnum = (typeof TallerScalarFieldEnum)[keyof typeof TallerScalarFieldEnum]


  export const Alumno_tallerScalarFieldEnum: {
    id: 'id',
    id_alumno: 'id_alumno',
    id_taller: 'id_taller',
    fecha_inscripcion: 'fecha_inscripcion',
    horas_asignadas: 'horas_asignadas'
  };

  export type Alumno_tallerScalarFieldEnum = (typeof Alumno_tallerScalarFieldEnum)[keyof typeof Alumno_tallerScalarFieldEnum]


  export const ComprobanteScalarFieldEnum: {
    id_comprobante: 'id_comprobante',
    id_alumno: 'id_alumno',
    id_taller: 'id_taller',
    fecha_pago: 'fecha_pago',
    monto: 'monto',
    estado: 'estado'
  };

  export type ComprobanteScalarFieldEnum = (typeof ComprobanteScalarFieldEnum)[keyof typeof ComprobanteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type maestroWhereInput = {
    AND?: maestroWhereInput | maestroWhereInput[]
    OR?: maestroWhereInput[]
    NOT?: maestroWhereInput | maestroWhereInput[]
    id_maestro?: IntFilter<"maestro"> | number
    nombre?: StringFilter<"maestro"> | string
    apellido?: StringFilter<"maestro"> | string
    dni?: StringNullableFilter<"maestro"> | string | null
    telefono?: StringNullableFilter<"maestro"> | string | null
    cant_talleres?: IntFilter<"maestro"> | number
    talleres?: TallerListRelationFilter
  }

  export type maestroOrderByWithRelationInput = {
    id_maestro?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    cant_talleres?: SortOrder
    talleres?: tallerOrderByRelationAggregateInput
  }

  export type maestroWhereUniqueInput = Prisma.AtLeast<{
    id_maestro?: number
    dni?: string
    AND?: maestroWhereInput | maestroWhereInput[]
    OR?: maestroWhereInput[]
    NOT?: maestroWhereInput | maestroWhereInput[]
    nombre?: StringFilter<"maestro"> | string
    apellido?: StringFilter<"maestro"> | string
    telefono?: StringNullableFilter<"maestro"> | string | null
    cant_talleres?: IntFilter<"maestro"> | number
    talleres?: TallerListRelationFilter
  }, "id_maestro" | "dni">

  export type maestroOrderByWithAggregationInput = {
    id_maestro?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    cant_talleres?: SortOrder
    _count?: maestroCountOrderByAggregateInput
    _avg?: maestroAvgOrderByAggregateInput
    _max?: maestroMaxOrderByAggregateInput
    _min?: maestroMinOrderByAggregateInput
    _sum?: maestroSumOrderByAggregateInput
  }

  export type maestroScalarWhereWithAggregatesInput = {
    AND?: maestroScalarWhereWithAggregatesInput | maestroScalarWhereWithAggregatesInput[]
    OR?: maestroScalarWhereWithAggregatesInput[]
    NOT?: maestroScalarWhereWithAggregatesInput | maestroScalarWhereWithAggregatesInput[]
    id_maestro?: IntWithAggregatesFilter<"maestro"> | number
    nombre?: StringWithAggregatesFilter<"maestro"> | string
    apellido?: StringWithAggregatesFilter<"maestro"> | string
    dni?: StringNullableWithAggregatesFilter<"maestro"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"maestro"> | string | null
    cant_talleres?: IntWithAggregatesFilter<"maestro"> | number
  }

  export type alumnoWhereInput = {
    AND?: alumnoWhereInput | alumnoWhereInput[]
    OR?: alumnoWhereInput[]
    NOT?: alumnoWhereInput | alumnoWhereInput[]
    id_alumno?: IntFilter<"alumno"> | number
    nombre?: StringFilter<"alumno"> | string
    apellido?: StringFilter<"alumno"> | string
    dni?: StringNullableFilter<"alumno"> | string | null
    direccion?: StringNullableFilter<"alumno"> | string | null
    telefono_madre?: StringNullableFilter<"alumno"> | string | null
    telefono_padre?: StringNullableFilter<"alumno"> | string | null
    inscripciones?: Alumno_tallerListRelationFilter
    comprobantes?: ComprobanteListRelationFilter
  }

  export type alumnoOrderByWithRelationInput = {
    id_alumno?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    telefono_madre?: SortOrderInput | SortOrder
    telefono_padre?: SortOrderInput | SortOrder
    inscripciones?: alumno_tallerOrderByRelationAggregateInput
    comprobantes?: comprobanteOrderByRelationAggregateInput
  }

  export type alumnoWhereUniqueInput = Prisma.AtLeast<{
    id_alumno?: number
    dni?: string
    AND?: alumnoWhereInput | alumnoWhereInput[]
    OR?: alumnoWhereInput[]
    NOT?: alumnoWhereInput | alumnoWhereInput[]
    nombre?: StringFilter<"alumno"> | string
    apellido?: StringFilter<"alumno"> | string
    direccion?: StringNullableFilter<"alumno"> | string | null
    telefono_madre?: StringNullableFilter<"alumno"> | string | null
    telefono_padre?: StringNullableFilter<"alumno"> | string | null
    inscripciones?: Alumno_tallerListRelationFilter
    comprobantes?: ComprobanteListRelationFilter
  }, "id_alumno" | "dni">

  export type alumnoOrderByWithAggregationInput = {
    id_alumno?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    telefono_madre?: SortOrderInput | SortOrder
    telefono_padre?: SortOrderInput | SortOrder
    _count?: alumnoCountOrderByAggregateInput
    _avg?: alumnoAvgOrderByAggregateInput
    _max?: alumnoMaxOrderByAggregateInput
    _min?: alumnoMinOrderByAggregateInput
    _sum?: alumnoSumOrderByAggregateInput
  }

  export type alumnoScalarWhereWithAggregatesInput = {
    AND?: alumnoScalarWhereWithAggregatesInput | alumnoScalarWhereWithAggregatesInput[]
    OR?: alumnoScalarWhereWithAggregatesInput[]
    NOT?: alumnoScalarWhereWithAggregatesInput | alumnoScalarWhereWithAggregatesInput[]
    id_alumno?: IntWithAggregatesFilter<"alumno"> | number
    nombre?: StringWithAggregatesFilter<"alumno"> | string
    apellido?: StringWithAggregatesFilter<"alumno"> | string
    dni?: StringNullableWithAggregatesFilter<"alumno"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"alumno"> | string | null
    telefono_madre?: StringNullableWithAggregatesFilter<"alumno"> | string | null
    telefono_padre?: StringNullableWithAggregatesFilter<"alumno"> | string | null
  }

  export type tallerWhereInput = {
    AND?: tallerWhereInput | tallerWhereInput[]
    OR?: tallerWhereInput[]
    NOT?: tallerWhereInput | tallerWhereInput[]
    id_taller?: IntFilter<"taller"> | number
    id_maestro?: IntFilter<"taller"> | number
    nombre?: StringFilter<"taller"> | string
    fecha_ini?: DateTimeFilter<"taller"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"taller"> | Date | string | null
    horario?: StringNullableFilter<"taller"> | string | null
    dias?: StringNullableFilter<"taller"> | string | null
    auxiliar?: StringNullableFilter<"taller"> | string | null
    cupo?: IntFilter<"taller"> | number
    maestro?: XOR<MaestroRelationFilter, maestroWhereInput>
    alumnos?: Alumno_tallerListRelationFilter
    comprobantes?: ComprobanteListRelationFilter
  }

  export type tallerOrderByWithRelationInput = {
    id_taller?: SortOrder
    id_maestro?: SortOrder
    nombre?: SortOrder
    fecha_ini?: SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    horario?: SortOrderInput | SortOrder
    dias?: SortOrderInput | SortOrder
    auxiliar?: SortOrderInput | SortOrder
    cupo?: SortOrder
    maestro?: maestroOrderByWithRelationInput
    alumnos?: alumno_tallerOrderByRelationAggregateInput
    comprobantes?: comprobanteOrderByRelationAggregateInput
  }

  export type tallerWhereUniqueInput = Prisma.AtLeast<{
    id_taller?: number
    AND?: tallerWhereInput | tallerWhereInput[]
    OR?: tallerWhereInput[]
    NOT?: tallerWhereInput | tallerWhereInput[]
    id_maestro?: IntFilter<"taller"> | number
    nombre?: StringFilter<"taller"> | string
    fecha_ini?: DateTimeFilter<"taller"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"taller"> | Date | string | null
    horario?: StringNullableFilter<"taller"> | string | null
    dias?: StringNullableFilter<"taller"> | string | null
    auxiliar?: StringNullableFilter<"taller"> | string | null
    cupo?: IntFilter<"taller"> | number
    maestro?: XOR<MaestroRelationFilter, maestroWhereInput>
    alumnos?: Alumno_tallerListRelationFilter
    comprobantes?: ComprobanteListRelationFilter
  }, "id_taller">

  export type tallerOrderByWithAggregationInput = {
    id_taller?: SortOrder
    id_maestro?: SortOrder
    nombre?: SortOrder
    fecha_ini?: SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    horario?: SortOrderInput | SortOrder
    dias?: SortOrderInput | SortOrder
    auxiliar?: SortOrderInput | SortOrder
    cupo?: SortOrder
    _count?: tallerCountOrderByAggregateInput
    _avg?: tallerAvgOrderByAggregateInput
    _max?: tallerMaxOrderByAggregateInput
    _min?: tallerMinOrderByAggregateInput
    _sum?: tallerSumOrderByAggregateInput
  }

  export type tallerScalarWhereWithAggregatesInput = {
    AND?: tallerScalarWhereWithAggregatesInput | tallerScalarWhereWithAggregatesInput[]
    OR?: tallerScalarWhereWithAggregatesInput[]
    NOT?: tallerScalarWhereWithAggregatesInput | tallerScalarWhereWithAggregatesInput[]
    id_taller?: IntWithAggregatesFilter<"taller"> | number
    id_maestro?: IntWithAggregatesFilter<"taller"> | number
    nombre?: StringWithAggregatesFilter<"taller"> | string
    fecha_ini?: DateTimeWithAggregatesFilter<"taller"> | Date | string
    fecha_fin?: DateTimeNullableWithAggregatesFilter<"taller"> | Date | string | null
    horario?: StringNullableWithAggregatesFilter<"taller"> | string | null
    dias?: StringNullableWithAggregatesFilter<"taller"> | string | null
    auxiliar?: StringNullableWithAggregatesFilter<"taller"> | string | null
    cupo?: IntWithAggregatesFilter<"taller"> | number
  }

  export type alumno_tallerWhereInput = {
    AND?: alumno_tallerWhereInput | alumno_tallerWhereInput[]
    OR?: alumno_tallerWhereInput[]
    NOT?: alumno_tallerWhereInput | alumno_tallerWhereInput[]
    id?: IntFilter<"alumno_taller"> | number
    id_alumno?: IntFilter<"alumno_taller"> | number
    id_taller?: IntFilter<"alumno_taller"> | number
    fecha_inscripcion?: DateTimeFilter<"alumno_taller"> | Date | string
    horas_asignadas?: IntFilter<"alumno_taller"> | number
    alumno?: XOR<AlumnoRelationFilter, alumnoWhereInput>
    taller?: XOR<TallerRelationFilter, tallerWhereInput>
  }

  export type alumno_tallerOrderByWithRelationInput = {
    id?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    fecha_inscripcion?: SortOrder
    horas_asignadas?: SortOrder
    alumno?: alumnoOrderByWithRelationInput
    taller?: tallerOrderByWithRelationInput
  }

  export type alumno_tallerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    id_alumno_id_taller?: alumno_tallerId_alumnoId_tallerCompoundUniqueInput
    AND?: alumno_tallerWhereInput | alumno_tallerWhereInput[]
    OR?: alumno_tallerWhereInput[]
    NOT?: alumno_tallerWhereInput | alumno_tallerWhereInput[]
    id_alumno?: IntFilter<"alumno_taller"> | number
    id_taller?: IntFilter<"alumno_taller"> | number
    fecha_inscripcion?: DateTimeFilter<"alumno_taller"> | Date | string
    horas_asignadas?: IntFilter<"alumno_taller"> | number
    alumno?: XOR<AlumnoRelationFilter, alumnoWhereInput>
    taller?: XOR<TallerRelationFilter, tallerWhereInput>
  }, "id" | "id_alumno_id_taller">

  export type alumno_tallerOrderByWithAggregationInput = {
    id?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    fecha_inscripcion?: SortOrder
    horas_asignadas?: SortOrder
    _count?: alumno_tallerCountOrderByAggregateInput
    _avg?: alumno_tallerAvgOrderByAggregateInput
    _max?: alumno_tallerMaxOrderByAggregateInput
    _min?: alumno_tallerMinOrderByAggregateInput
    _sum?: alumno_tallerSumOrderByAggregateInput
  }

  export type alumno_tallerScalarWhereWithAggregatesInput = {
    AND?: alumno_tallerScalarWhereWithAggregatesInput | alumno_tallerScalarWhereWithAggregatesInput[]
    OR?: alumno_tallerScalarWhereWithAggregatesInput[]
    NOT?: alumno_tallerScalarWhereWithAggregatesInput | alumno_tallerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"alumno_taller"> | number
    id_alumno?: IntWithAggregatesFilter<"alumno_taller"> | number
    id_taller?: IntWithAggregatesFilter<"alumno_taller"> | number
    fecha_inscripcion?: DateTimeWithAggregatesFilter<"alumno_taller"> | Date | string
    horas_asignadas?: IntWithAggregatesFilter<"alumno_taller"> | number
  }

  export type comprobanteWhereInput = {
    AND?: comprobanteWhereInput | comprobanteWhereInput[]
    OR?: comprobanteWhereInput[]
    NOT?: comprobanteWhereInput | comprobanteWhereInput[]
    id_comprobante?: IntFilter<"comprobante"> | number
    id_alumno?: IntFilter<"comprobante"> | number
    id_taller?: IntNullableFilter<"comprobante"> | number | null
    fecha_pago?: DateTimeFilter<"comprobante"> | Date | string
    monto?: DecimalFilter<"comprobante"> | Decimal | DecimalJsLike | number | string
    estado?: StringFilter<"comprobante"> | string
    alumno?: XOR<AlumnoRelationFilter, alumnoWhereInput>
    taller?: XOR<TallerNullableRelationFilter, tallerWhereInput> | null
  }

  export type comprobanteOrderByWithRelationInput = {
    id_comprobante?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrderInput | SortOrder
    fecha_pago?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    alumno?: alumnoOrderByWithRelationInput
    taller?: tallerOrderByWithRelationInput
  }

  export type comprobanteWhereUniqueInput = Prisma.AtLeast<{
    id_comprobante?: number
    AND?: comprobanteWhereInput | comprobanteWhereInput[]
    OR?: comprobanteWhereInput[]
    NOT?: comprobanteWhereInput | comprobanteWhereInput[]
    id_alumno?: IntFilter<"comprobante"> | number
    id_taller?: IntNullableFilter<"comprobante"> | number | null
    fecha_pago?: DateTimeFilter<"comprobante"> | Date | string
    monto?: DecimalFilter<"comprobante"> | Decimal | DecimalJsLike | number | string
    estado?: StringFilter<"comprobante"> | string
    alumno?: XOR<AlumnoRelationFilter, alumnoWhereInput>
    taller?: XOR<TallerNullableRelationFilter, tallerWhereInput> | null
  }, "id_comprobante">

  export type comprobanteOrderByWithAggregationInput = {
    id_comprobante?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrderInput | SortOrder
    fecha_pago?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    _count?: comprobanteCountOrderByAggregateInput
    _avg?: comprobanteAvgOrderByAggregateInput
    _max?: comprobanteMaxOrderByAggregateInput
    _min?: comprobanteMinOrderByAggregateInput
    _sum?: comprobanteSumOrderByAggregateInput
  }

  export type comprobanteScalarWhereWithAggregatesInput = {
    AND?: comprobanteScalarWhereWithAggregatesInput | comprobanteScalarWhereWithAggregatesInput[]
    OR?: comprobanteScalarWhereWithAggregatesInput[]
    NOT?: comprobanteScalarWhereWithAggregatesInput | comprobanteScalarWhereWithAggregatesInput[]
    id_comprobante?: IntWithAggregatesFilter<"comprobante"> | number
    id_alumno?: IntWithAggregatesFilter<"comprobante"> | number
    id_taller?: IntNullableWithAggregatesFilter<"comprobante"> | number | null
    fecha_pago?: DateTimeWithAggregatesFilter<"comprobante"> | Date | string
    monto?: DecimalWithAggregatesFilter<"comprobante"> | Decimal | DecimalJsLike | number | string
    estado?: StringWithAggregatesFilter<"comprobante"> | string
  }

  export type maestroCreateInput = {
    nombre: string
    apellido: string
    dni?: string | null
    telefono?: string | null
    cant_talleres?: number
    talleres?: tallerCreateNestedManyWithoutMaestroInput
  }

  export type maestroUncheckedCreateInput = {
    id_maestro?: number
    nombre: string
    apellido: string
    dni?: string | null
    telefono?: string | null
    cant_talleres?: number
    talleres?: tallerUncheckedCreateNestedManyWithoutMaestroInput
  }

  export type maestroUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cant_talleres?: IntFieldUpdateOperationsInput | number
    talleres?: tallerUpdateManyWithoutMaestroNestedInput
  }

  export type maestroUncheckedUpdateInput = {
    id_maestro?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cant_talleres?: IntFieldUpdateOperationsInput | number
    talleres?: tallerUncheckedUpdateManyWithoutMaestroNestedInput
  }

  export type maestroCreateManyInput = {
    id_maestro?: number
    nombre: string
    apellido: string
    dni?: string | null
    telefono?: string | null
    cant_talleres?: number
  }

  export type maestroUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cant_talleres?: IntFieldUpdateOperationsInput | number
  }

  export type maestroUncheckedUpdateManyInput = {
    id_maestro?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cant_talleres?: IntFieldUpdateOperationsInput | number
  }

  export type alumnoCreateInput = {
    nombre: string
    apellido: string
    dni?: string | null
    direccion?: string | null
    telefono_madre?: string | null
    telefono_padre?: string | null
    inscripciones?: alumno_tallerCreateNestedManyWithoutAlumnoInput
    comprobantes?: comprobanteCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoUncheckedCreateInput = {
    id_alumno?: number
    nombre: string
    apellido: string
    dni?: string | null
    direccion?: string | null
    telefono_madre?: string | null
    telefono_padre?: string | null
    inscripciones?: alumno_tallerUncheckedCreateNestedManyWithoutAlumnoInput
    comprobantes?: comprobanteUncheckedCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_madre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_padre?: NullableStringFieldUpdateOperationsInput | string | null
    inscripciones?: alumno_tallerUpdateManyWithoutAlumnoNestedInput
    comprobantes?: comprobanteUpdateManyWithoutAlumnoNestedInput
  }

  export type alumnoUncheckedUpdateInput = {
    id_alumno?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_madre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_padre?: NullableStringFieldUpdateOperationsInput | string | null
    inscripciones?: alumno_tallerUncheckedUpdateManyWithoutAlumnoNestedInput
    comprobantes?: comprobanteUncheckedUpdateManyWithoutAlumnoNestedInput
  }

  export type alumnoCreateManyInput = {
    id_alumno?: number
    nombre: string
    apellido: string
    dni?: string | null
    direccion?: string | null
    telefono_madre?: string | null
    telefono_padre?: string | null
  }

  export type alumnoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_madre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_padre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type alumnoUncheckedUpdateManyInput = {
    id_alumno?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_madre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_padre?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tallerCreateInput = {
    nombre: string
    fecha_ini: Date | string
    fecha_fin?: Date | string | null
    horario?: string | null
    dias?: string | null
    auxiliar?: string | null
    cupo: number
    maestro: maestroCreateNestedOneWithoutTalleresInput
    alumnos?: alumno_tallerCreateNestedManyWithoutTallerInput
    comprobantes?: comprobanteCreateNestedManyWithoutTallerInput
  }

  export type tallerUncheckedCreateInput = {
    id_taller?: number
    id_maestro: number
    nombre: string
    fecha_ini: Date | string
    fecha_fin?: Date | string | null
    horario?: string | null
    dias?: string | null
    auxiliar?: string | null
    cupo: number
    alumnos?: alumno_tallerUncheckedCreateNestedManyWithoutTallerInput
    comprobantes?: comprobanteUncheckedCreateNestedManyWithoutTallerInput
  }

  export type tallerUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
    maestro?: maestroUpdateOneRequiredWithoutTalleresNestedInput
    alumnos?: alumno_tallerUpdateManyWithoutTallerNestedInput
    comprobantes?: comprobanteUpdateManyWithoutTallerNestedInput
  }

  export type tallerUncheckedUpdateInput = {
    id_taller?: IntFieldUpdateOperationsInput | number
    id_maestro?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
    alumnos?: alumno_tallerUncheckedUpdateManyWithoutTallerNestedInput
    comprobantes?: comprobanteUncheckedUpdateManyWithoutTallerNestedInput
  }

  export type tallerCreateManyInput = {
    id_taller?: number
    id_maestro: number
    nombre: string
    fecha_ini: Date | string
    fecha_fin?: Date | string | null
    horario?: string | null
    dias?: string | null
    auxiliar?: string | null
    cupo: number
  }

  export type tallerUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
  }

  export type tallerUncheckedUpdateManyInput = {
    id_taller?: IntFieldUpdateOperationsInput | number
    id_maestro?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
  }

  export type alumno_tallerCreateInput = {
    fecha_inscripcion?: Date | string
    horas_asignadas?: number
    alumno: alumnoCreateNestedOneWithoutInscripcionesInput
    taller: tallerCreateNestedOneWithoutAlumnosInput
  }

  export type alumno_tallerUncheckedCreateInput = {
    id?: number
    id_alumno: number
    id_taller: number
    fecha_inscripcion?: Date | string
    horas_asignadas?: number
  }

  export type alumno_tallerUpdateInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    horas_asignadas?: IntFieldUpdateOperationsInput | number
    alumno?: alumnoUpdateOneRequiredWithoutInscripcionesNestedInput
    taller?: tallerUpdateOneRequiredWithoutAlumnosNestedInput
  }

  export type alumno_tallerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_alumno?: IntFieldUpdateOperationsInput | number
    id_taller?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    horas_asignadas?: IntFieldUpdateOperationsInput | number
  }

  export type alumno_tallerCreateManyInput = {
    id?: number
    id_alumno: number
    id_taller: number
    fecha_inscripcion?: Date | string
    horas_asignadas?: number
  }

  export type alumno_tallerUpdateManyMutationInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    horas_asignadas?: IntFieldUpdateOperationsInput | number
  }

  export type alumno_tallerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_alumno?: IntFieldUpdateOperationsInput | number
    id_taller?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    horas_asignadas?: IntFieldUpdateOperationsInput | number
  }

  export type comprobanteCreateInput = {
    fecha_pago: Date | string
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    alumno: alumnoCreateNestedOneWithoutComprobantesInput
    taller?: tallerCreateNestedOneWithoutComprobantesInput
  }

  export type comprobanteUncheckedCreateInput = {
    id_comprobante?: number
    id_alumno: number
    id_taller?: number | null
    fecha_pago: Date | string
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
  }

  export type comprobanteUpdateInput = {
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    alumno?: alumnoUpdateOneRequiredWithoutComprobantesNestedInput
    taller?: tallerUpdateOneWithoutComprobantesNestedInput
  }

  export type comprobanteUncheckedUpdateInput = {
    id_comprobante?: IntFieldUpdateOperationsInput | number
    id_alumno?: IntFieldUpdateOperationsInput | number
    id_taller?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type comprobanteCreateManyInput = {
    id_comprobante?: number
    id_alumno: number
    id_taller?: number | null
    fecha_pago: Date | string
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
  }

  export type comprobanteUpdateManyMutationInput = {
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type comprobanteUncheckedUpdateManyInput = {
    id_comprobante?: IntFieldUpdateOperationsInput | number
    id_alumno?: IntFieldUpdateOperationsInput | number
    id_taller?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type TallerListRelationFilter = {
    every?: tallerWhereInput
    some?: tallerWhereInput
    none?: tallerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type tallerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type maestroCountOrderByAggregateInput = {
    id_maestro?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    cant_talleres?: SortOrder
  }

  export type maestroAvgOrderByAggregateInput = {
    id_maestro?: SortOrder
    cant_talleres?: SortOrder
  }

  export type maestroMaxOrderByAggregateInput = {
    id_maestro?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    cant_talleres?: SortOrder
  }

  export type maestroMinOrderByAggregateInput = {
    id_maestro?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    cant_talleres?: SortOrder
  }

  export type maestroSumOrderByAggregateInput = {
    id_maestro?: SortOrder
    cant_talleres?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Alumno_tallerListRelationFilter = {
    every?: alumno_tallerWhereInput
    some?: alumno_tallerWhereInput
    none?: alumno_tallerWhereInput
  }

  export type ComprobanteListRelationFilter = {
    every?: comprobanteWhereInput
    some?: comprobanteWhereInput
    none?: comprobanteWhereInput
  }

  export type alumno_tallerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comprobanteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type alumnoCountOrderByAggregateInput = {
    id_alumno?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    direccion?: SortOrder
    telefono_madre?: SortOrder
    telefono_padre?: SortOrder
  }

  export type alumnoAvgOrderByAggregateInput = {
    id_alumno?: SortOrder
  }

  export type alumnoMaxOrderByAggregateInput = {
    id_alumno?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    direccion?: SortOrder
    telefono_madre?: SortOrder
    telefono_padre?: SortOrder
  }

  export type alumnoMinOrderByAggregateInput = {
    id_alumno?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    direccion?: SortOrder
    telefono_madre?: SortOrder
    telefono_padre?: SortOrder
  }

  export type alumnoSumOrderByAggregateInput = {
    id_alumno?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MaestroRelationFilter = {
    is?: maestroWhereInput
    isNot?: maestroWhereInput
  }

  export type tallerCountOrderByAggregateInput = {
    id_taller?: SortOrder
    id_maestro?: SortOrder
    nombre?: SortOrder
    fecha_ini?: SortOrder
    fecha_fin?: SortOrder
    horario?: SortOrder
    dias?: SortOrder
    auxiliar?: SortOrder
    cupo?: SortOrder
  }

  export type tallerAvgOrderByAggregateInput = {
    id_taller?: SortOrder
    id_maestro?: SortOrder
    cupo?: SortOrder
  }

  export type tallerMaxOrderByAggregateInput = {
    id_taller?: SortOrder
    id_maestro?: SortOrder
    nombre?: SortOrder
    fecha_ini?: SortOrder
    fecha_fin?: SortOrder
    horario?: SortOrder
    dias?: SortOrder
    auxiliar?: SortOrder
    cupo?: SortOrder
  }

  export type tallerMinOrderByAggregateInput = {
    id_taller?: SortOrder
    id_maestro?: SortOrder
    nombre?: SortOrder
    fecha_ini?: SortOrder
    fecha_fin?: SortOrder
    horario?: SortOrder
    dias?: SortOrder
    auxiliar?: SortOrder
    cupo?: SortOrder
  }

  export type tallerSumOrderByAggregateInput = {
    id_taller?: SortOrder
    id_maestro?: SortOrder
    cupo?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AlumnoRelationFilter = {
    is?: alumnoWhereInput
    isNot?: alumnoWhereInput
  }

  export type TallerRelationFilter = {
    is?: tallerWhereInput
    isNot?: tallerWhereInput
  }

  export type alumno_tallerId_alumnoId_tallerCompoundUniqueInput = {
    id_alumno: number
    id_taller: number
  }

  export type alumno_tallerCountOrderByAggregateInput = {
    id?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    fecha_inscripcion?: SortOrder
    horas_asignadas?: SortOrder
  }

  export type alumno_tallerAvgOrderByAggregateInput = {
    id?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    horas_asignadas?: SortOrder
  }

  export type alumno_tallerMaxOrderByAggregateInput = {
    id?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    fecha_inscripcion?: SortOrder
    horas_asignadas?: SortOrder
  }

  export type alumno_tallerMinOrderByAggregateInput = {
    id?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    fecha_inscripcion?: SortOrder
    horas_asignadas?: SortOrder
  }

  export type alumno_tallerSumOrderByAggregateInput = {
    id?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    horas_asignadas?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TallerNullableRelationFilter = {
    is?: tallerWhereInput | null
    isNot?: tallerWhereInput | null
  }

  export type comprobanteCountOrderByAggregateInput = {
    id_comprobante?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    fecha_pago?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
  }

  export type comprobanteAvgOrderByAggregateInput = {
    id_comprobante?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    monto?: SortOrder
  }

  export type comprobanteMaxOrderByAggregateInput = {
    id_comprobante?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    fecha_pago?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
  }

  export type comprobanteMinOrderByAggregateInput = {
    id_comprobante?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    fecha_pago?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
  }

  export type comprobanteSumOrderByAggregateInput = {
    id_comprobante?: SortOrder
    id_alumno?: SortOrder
    id_taller?: SortOrder
    monto?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type tallerCreateNestedManyWithoutMaestroInput = {
    create?: XOR<tallerCreateWithoutMaestroInput, tallerUncheckedCreateWithoutMaestroInput> | tallerCreateWithoutMaestroInput[] | tallerUncheckedCreateWithoutMaestroInput[]
    connectOrCreate?: tallerCreateOrConnectWithoutMaestroInput | tallerCreateOrConnectWithoutMaestroInput[]
    createMany?: tallerCreateManyMaestroInputEnvelope
    connect?: tallerWhereUniqueInput | tallerWhereUniqueInput[]
  }

  export type tallerUncheckedCreateNestedManyWithoutMaestroInput = {
    create?: XOR<tallerCreateWithoutMaestroInput, tallerUncheckedCreateWithoutMaestroInput> | tallerCreateWithoutMaestroInput[] | tallerUncheckedCreateWithoutMaestroInput[]
    connectOrCreate?: tallerCreateOrConnectWithoutMaestroInput | tallerCreateOrConnectWithoutMaestroInput[]
    createMany?: tallerCreateManyMaestroInputEnvelope
    connect?: tallerWhereUniqueInput | tallerWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type tallerUpdateManyWithoutMaestroNestedInput = {
    create?: XOR<tallerCreateWithoutMaestroInput, tallerUncheckedCreateWithoutMaestroInput> | tallerCreateWithoutMaestroInput[] | tallerUncheckedCreateWithoutMaestroInput[]
    connectOrCreate?: tallerCreateOrConnectWithoutMaestroInput | tallerCreateOrConnectWithoutMaestroInput[]
    upsert?: tallerUpsertWithWhereUniqueWithoutMaestroInput | tallerUpsertWithWhereUniqueWithoutMaestroInput[]
    createMany?: tallerCreateManyMaestroInputEnvelope
    set?: tallerWhereUniqueInput | tallerWhereUniqueInput[]
    disconnect?: tallerWhereUniqueInput | tallerWhereUniqueInput[]
    delete?: tallerWhereUniqueInput | tallerWhereUniqueInput[]
    connect?: tallerWhereUniqueInput | tallerWhereUniqueInput[]
    update?: tallerUpdateWithWhereUniqueWithoutMaestroInput | tallerUpdateWithWhereUniqueWithoutMaestroInput[]
    updateMany?: tallerUpdateManyWithWhereWithoutMaestroInput | tallerUpdateManyWithWhereWithoutMaestroInput[]
    deleteMany?: tallerScalarWhereInput | tallerScalarWhereInput[]
  }

  export type tallerUncheckedUpdateManyWithoutMaestroNestedInput = {
    create?: XOR<tallerCreateWithoutMaestroInput, tallerUncheckedCreateWithoutMaestroInput> | tallerCreateWithoutMaestroInput[] | tallerUncheckedCreateWithoutMaestroInput[]
    connectOrCreate?: tallerCreateOrConnectWithoutMaestroInput | tallerCreateOrConnectWithoutMaestroInput[]
    upsert?: tallerUpsertWithWhereUniqueWithoutMaestroInput | tallerUpsertWithWhereUniqueWithoutMaestroInput[]
    createMany?: tallerCreateManyMaestroInputEnvelope
    set?: tallerWhereUniqueInput | tallerWhereUniqueInput[]
    disconnect?: tallerWhereUniqueInput | tallerWhereUniqueInput[]
    delete?: tallerWhereUniqueInput | tallerWhereUniqueInput[]
    connect?: tallerWhereUniqueInput | tallerWhereUniqueInput[]
    update?: tallerUpdateWithWhereUniqueWithoutMaestroInput | tallerUpdateWithWhereUniqueWithoutMaestroInput[]
    updateMany?: tallerUpdateManyWithWhereWithoutMaestroInput | tallerUpdateManyWithWhereWithoutMaestroInput[]
    deleteMany?: tallerScalarWhereInput | tallerScalarWhereInput[]
  }

  export type alumno_tallerCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<alumno_tallerCreateWithoutAlumnoInput, alumno_tallerUncheckedCreateWithoutAlumnoInput> | alumno_tallerCreateWithoutAlumnoInput[] | alumno_tallerUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: alumno_tallerCreateOrConnectWithoutAlumnoInput | alumno_tallerCreateOrConnectWithoutAlumnoInput[]
    createMany?: alumno_tallerCreateManyAlumnoInputEnvelope
    connect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
  }

  export type comprobanteCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<comprobanteCreateWithoutAlumnoInput, comprobanteUncheckedCreateWithoutAlumnoInput> | comprobanteCreateWithoutAlumnoInput[] | comprobanteUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: comprobanteCreateOrConnectWithoutAlumnoInput | comprobanteCreateOrConnectWithoutAlumnoInput[]
    createMany?: comprobanteCreateManyAlumnoInputEnvelope
    connect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
  }

  export type alumno_tallerUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<alumno_tallerCreateWithoutAlumnoInput, alumno_tallerUncheckedCreateWithoutAlumnoInput> | alumno_tallerCreateWithoutAlumnoInput[] | alumno_tallerUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: alumno_tallerCreateOrConnectWithoutAlumnoInput | alumno_tallerCreateOrConnectWithoutAlumnoInput[]
    createMany?: alumno_tallerCreateManyAlumnoInputEnvelope
    connect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
  }

  export type comprobanteUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<comprobanteCreateWithoutAlumnoInput, comprobanteUncheckedCreateWithoutAlumnoInput> | comprobanteCreateWithoutAlumnoInput[] | comprobanteUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: comprobanteCreateOrConnectWithoutAlumnoInput | comprobanteCreateOrConnectWithoutAlumnoInput[]
    createMany?: comprobanteCreateManyAlumnoInputEnvelope
    connect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
  }

  export type alumno_tallerUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<alumno_tallerCreateWithoutAlumnoInput, alumno_tallerUncheckedCreateWithoutAlumnoInput> | alumno_tallerCreateWithoutAlumnoInput[] | alumno_tallerUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: alumno_tallerCreateOrConnectWithoutAlumnoInput | alumno_tallerCreateOrConnectWithoutAlumnoInput[]
    upsert?: alumno_tallerUpsertWithWhereUniqueWithoutAlumnoInput | alumno_tallerUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: alumno_tallerCreateManyAlumnoInputEnvelope
    set?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    disconnect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    delete?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    connect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    update?: alumno_tallerUpdateWithWhereUniqueWithoutAlumnoInput | alumno_tallerUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: alumno_tallerUpdateManyWithWhereWithoutAlumnoInput | alumno_tallerUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: alumno_tallerScalarWhereInput | alumno_tallerScalarWhereInput[]
  }

  export type comprobanteUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<comprobanteCreateWithoutAlumnoInput, comprobanteUncheckedCreateWithoutAlumnoInput> | comprobanteCreateWithoutAlumnoInput[] | comprobanteUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: comprobanteCreateOrConnectWithoutAlumnoInput | comprobanteCreateOrConnectWithoutAlumnoInput[]
    upsert?: comprobanteUpsertWithWhereUniqueWithoutAlumnoInput | comprobanteUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: comprobanteCreateManyAlumnoInputEnvelope
    set?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    disconnect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    delete?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    connect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    update?: comprobanteUpdateWithWhereUniqueWithoutAlumnoInput | comprobanteUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: comprobanteUpdateManyWithWhereWithoutAlumnoInput | comprobanteUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: comprobanteScalarWhereInput | comprobanteScalarWhereInput[]
  }

  export type alumno_tallerUncheckedUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<alumno_tallerCreateWithoutAlumnoInput, alumno_tallerUncheckedCreateWithoutAlumnoInput> | alumno_tallerCreateWithoutAlumnoInput[] | alumno_tallerUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: alumno_tallerCreateOrConnectWithoutAlumnoInput | alumno_tallerCreateOrConnectWithoutAlumnoInput[]
    upsert?: alumno_tallerUpsertWithWhereUniqueWithoutAlumnoInput | alumno_tallerUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: alumno_tallerCreateManyAlumnoInputEnvelope
    set?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    disconnect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    delete?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    connect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    update?: alumno_tallerUpdateWithWhereUniqueWithoutAlumnoInput | alumno_tallerUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: alumno_tallerUpdateManyWithWhereWithoutAlumnoInput | alumno_tallerUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: alumno_tallerScalarWhereInput | alumno_tallerScalarWhereInput[]
  }

  export type comprobanteUncheckedUpdateManyWithoutAlumnoNestedInput = {
    create?: XOR<comprobanteCreateWithoutAlumnoInput, comprobanteUncheckedCreateWithoutAlumnoInput> | comprobanteCreateWithoutAlumnoInput[] | comprobanteUncheckedCreateWithoutAlumnoInput[]
    connectOrCreate?: comprobanteCreateOrConnectWithoutAlumnoInput | comprobanteCreateOrConnectWithoutAlumnoInput[]
    upsert?: comprobanteUpsertWithWhereUniqueWithoutAlumnoInput | comprobanteUpsertWithWhereUniqueWithoutAlumnoInput[]
    createMany?: comprobanteCreateManyAlumnoInputEnvelope
    set?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    disconnect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    delete?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    connect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    update?: comprobanteUpdateWithWhereUniqueWithoutAlumnoInput | comprobanteUpdateWithWhereUniqueWithoutAlumnoInput[]
    updateMany?: comprobanteUpdateManyWithWhereWithoutAlumnoInput | comprobanteUpdateManyWithWhereWithoutAlumnoInput[]
    deleteMany?: comprobanteScalarWhereInput | comprobanteScalarWhereInput[]
  }

  export type maestroCreateNestedOneWithoutTalleresInput = {
    create?: XOR<maestroCreateWithoutTalleresInput, maestroUncheckedCreateWithoutTalleresInput>
    connectOrCreate?: maestroCreateOrConnectWithoutTalleresInput
    connect?: maestroWhereUniqueInput
  }

  export type alumno_tallerCreateNestedManyWithoutTallerInput = {
    create?: XOR<alumno_tallerCreateWithoutTallerInput, alumno_tallerUncheckedCreateWithoutTallerInput> | alumno_tallerCreateWithoutTallerInput[] | alumno_tallerUncheckedCreateWithoutTallerInput[]
    connectOrCreate?: alumno_tallerCreateOrConnectWithoutTallerInput | alumno_tallerCreateOrConnectWithoutTallerInput[]
    createMany?: alumno_tallerCreateManyTallerInputEnvelope
    connect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
  }

  export type comprobanteCreateNestedManyWithoutTallerInput = {
    create?: XOR<comprobanteCreateWithoutTallerInput, comprobanteUncheckedCreateWithoutTallerInput> | comprobanteCreateWithoutTallerInput[] | comprobanteUncheckedCreateWithoutTallerInput[]
    connectOrCreate?: comprobanteCreateOrConnectWithoutTallerInput | comprobanteCreateOrConnectWithoutTallerInput[]
    createMany?: comprobanteCreateManyTallerInputEnvelope
    connect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
  }

  export type alumno_tallerUncheckedCreateNestedManyWithoutTallerInput = {
    create?: XOR<alumno_tallerCreateWithoutTallerInput, alumno_tallerUncheckedCreateWithoutTallerInput> | alumno_tallerCreateWithoutTallerInput[] | alumno_tallerUncheckedCreateWithoutTallerInput[]
    connectOrCreate?: alumno_tallerCreateOrConnectWithoutTallerInput | alumno_tallerCreateOrConnectWithoutTallerInput[]
    createMany?: alumno_tallerCreateManyTallerInputEnvelope
    connect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
  }

  export type comprobanteUncheckedCreateNestedManyWithoutTallerInput = {
    create?: XOR<comprobanteCreateWithoutTallerInput, comprobanteUncheckedCreateWithoutTallerInput> | comprobanteCreateWithoutTallerInput[] | comprobanteUncheckedCreateWithoutTallerInput[]
    connectOrCreate?: comprobanteCreateOrConnectWithoutTallerInput | comprobanteCreateOrConnectWithoutTallerInput[]
    createMany?: comprobanteCreateManyTallerInputEnvelope
    connect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type maestroUpdateOneRequiredWithoutTalleresNestedInput = {
    create?: XOR<maestroCreateWithoutTalleresInput, maestroUncheckedCreateWithoutTalleresInput>
    connectOrCreate?: maestroCreateOrConnectWithoutTalleresInput
    upsert?: maestroUpsertWithoutTalleresInput
    connect?: maestroWhereUniqueInput
    update?: XOR<XOR<maestroUpdateToOneWithWhereWithoutTalleresInput, maestroUpdateWithoutTalleresInput>, maestroUncheckedUpdateWithoutTalleresInput>
  }

  export type alumno_tallerUpdateManyWithoutTallerNestedInput = {
    create?: XOR<alumno_tallerCreateWithoutTallerInput, alumno_tallerUncheckedCreateWithoutTallerInput> | alumno_tallerCreateWithoutTallerInput[] | alumno_tallerUncheckedCreateWithoutTallerInput[]
    connectOrCreate?: alumno_tallerCreateOrConnectWithoutTallerInput | alumno_tallerCreateOrConnectWithoutTallerInput[]
    upsert?: alumno_tallerUpsertWithWhereUniqueWithoutTallerInput | alumno_tallerUpsertWithWhereUniqueWithoutTallerInput[]
    createMany?: alumno_tallerCreateManyTallerInputEnvelope
    set?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    disconnect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    delete?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    connect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    update?: alumno_tallerUpdateWithWhereUniqueWithoutTallerInput | alumno_tallerUpdateWithWhereUniqueWithoutTallerInput[]
    updateMany?: alumno_tallerUpdateManyWithWhereWithoutTallerInput | alumno_tallerUpdateManyWithWhereWithoutTallerInput[]
    deleteMany?: alumno_tallerScalarWhereInput | alumno_tallerScalarWhereInput[]
  }

  export type comprobanteUpdateManyWithoutTallerNestedInput = {
    create?: XOR<comprobanteCreateWithoutTallerInput, comprobanteUncheckedCreateWithoutTallerInput> | comprobanteCreateWithoutTallerInput[] | comprobanteUncheckedCreateWithoutTallerInput[]
    connectOrCreate?: comprobanteCreateOrConnectWithoutTallerInput | comprobanteCreateOrConnectWithoutTallerInput[]
    upsert?: comprobanteUpsertWithWhereUniqueWithoutTallerInput | comprobanteUpsertWithWhereUniqueWithoutTallerInput[]
    createMany?: comprobanteCreateManyTallerInputEnvelope
    set?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    disconnect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    delete?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    connect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    update?: comprobanteUpdateWithWhereUniqueWithoutTallerInput | comprobanteUpdateWithWhereUniqueWithoutTallerInput[]
    updateMany?: comprobanteUpdateManyWithWhereWithoutTallerInput | comprobanteUpdateManyWithWhereWithoutTallerInput[]
    deleteMany?: comprobanteScalarWhereInput | comprobanteScalarWhereInput[]
  }

  export type alumno_tallerUncheckedUpdateManyWithoutTallerNestedInput = {
    create?: XOR<alumno_tallerCreateWithoutTallerInput, alumno_tallerUncheckedCreateWithoutTallerInput> | alumno_tallerCreateWithoutTallerInput[] | alumno_tallerUncheckedCreateWithoutTallerInput[]
    connectOrCreate?: alumno_tallerCreateOrConnectWithoutTallerInput | alumno_tallerCreateOrConnectWithoutTallerInput[]
    upsert?: alumno_tallerUpsertWithWhereUniqueWithoutTallerInput | alumno_tallerUpsertWithWhereUniqueWithoutTallerInput[]
    createMany?: alumno_tallerCreateManyTallerInputEnvelope
    set?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    disconnect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    delete?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    connect?: alumno_tallerWhereUniqueInput | alumno_tallerWhereUniqueInput[]
    update?: alumno_tallerUpdateWithWhereUniqueWithoutTallerInput | alumno_tallerUpdateWithWhereUniqueWithoutTallerInput[]
    updateMany?: alumno_tallerUpdateManyWithWhereWithoutTallerInput | alumno_tallerUpdateManyWithWhereWithoutTallerInput[]
    deleteMany?: alumno_tallerScalarWhereInput | alumno_tallerScalarWhereInput[]
  }

  export type comprobanteUncheckedUpdateManyWithoutTallerNestedInput = {
    create?: XOR<comprobanteCreateWithoutTallerInput, comprobanteUncheckedCreateWithoutTallerInput> | comprobanteCreateWithoutTallerInput[] | comprobanteUncheckedCreateWithoutTallerInput[]
    connectOrCreate?: comprobanteCreateOrConnectWithoutTallerInput | comprobanteCreateOrConnectWithoutTallerInput[]
    upsert?: comprobanteUpsertWithWhereUniqueWithoutTallerInput | comprobanteUpsertWithWhereUniqueWithoutTallerInput[]
    createMany?: comprobanteCreateManyTallerInputEnvelope
    set?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    disconnect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    delete?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    connect?: comprobanteWhereUniqueInput | comprobanteWhereUniqueInput[]
    update?: comprobanteUpdateWithWhereUniqueWithoutTallerInput | comprobanteUpdateWithWhereUniqueWithoutTallerInput[]
    updateMany?: comprobanteUpdateManyWithWhereWithoutTallerInput | comprobanteUpdateManyWithWhereWithoutTallerInput[]
    deleteMany?: comprobanteScalarWhereInput | comprobanteScalarWhereInput[]
  }

  export type alumnoCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<alumnoCreateWithoutInscripcionesInput, alumnoUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: alumnoCreateOrConnectWithoutInscripcionesInput
    connect?: alumnoWhereUniqueInput
  }

  export type tallerCreateNestedOneWithoutAlumnosInput = {
    create?: XOR<tallerCreateWithoutAlumnosInput, tallerUncheckedCreateWithoutAlumnosInput>
    connectOrCreate?: tallerCreateOrConnectWithoutAlumnosInput
    connect?: tallerWhereUniqueInput
  }

  export type alumnoUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<alumnoCreateWithoutInscripcionesInput, alumnoUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: alumnoCreateOrConnectWithoutInscripcionesInput
    upsert?: alumnoUpsertWithoutInscripcionesInput
    connect?: alumnoWhereUniqueInput
    update?: XOR<XOR<alumnoUpdateToOneWithWhereWithoutInscripcionesInput, alumnoUpdateWithoutInscripcionesInput>, alumnoUncheckedUpdateWithoutInscripcionesInput>
  }

  export type tallerUpdateOneRequiredWithoutAlumnosNestedInput = {
    create?: XOR<tallerCreateWithoutAlumnosInput, tallerUncheckedCreateWithoutAlumnosInput>
    connectOrCreate?: tallerCreateOrConnectWithoutAlumnosInput
    upsert?: tallerUpsertWithoutAlumnosInput
    connect?: tallerWhereUniqueInput
    update?: XOR<XOR<tallerUpdateToOneWithWhereWithoutAlumnosInput, tallerUpdateWithoutAlumnosInput>, tallerUncheckedUpdateWithoutAlumnosInput>
  }

  export type alumnoCreateNestedOneWithoutComprobantesInput = {
    create?: XOR<alumnoCreateWithoutComprobantesInput, alumnoUncheckedCreateWithoutComprobantesInput>
    connectOrCreate?: alumnoCreateOrConnectWithoutComprobantesInput
    connect?: alumnoWhereUniqueInput
  }

  export type tallerCreateNestedOneWithoutComprobantesInput = {
    create?: XOR<tallerCreateWithoutComprobantesInput, tallerUncheckedCreateWithoutComprobantesInput>
    connectOrCreate?: tallerCreateOrConnectWithoutComprobantesInput
    connect?: tallerWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type alumnoUpdateOneRequiredWithoutComprobantesNestedInput = {
    create?: XOR<alumnoCreateWithoutComprobantesInput, alumnoUncheckedCreateWithoutComprobantesInput>
    connectOrCreate?: alumnoCreateOrConnectWithoutComprobantesInput
    upsert?: alumnoUpsertWithoutComprobantesInput
    connect?: alumnoWhereUniqueInput
    update?: XOR<XOR<alumnoUpdateToOneWithWhereWithoutComprobantesInput, alumnoUpdateWithoutComprobantesInput>, alumnoUncheckedUpdateWithoutComprobantesInput>
  }

  export type tallerUpdateOneWithoutComprobantesNestedInput = {
    create?: XOR<tallerCreateWithoutComprobantesInput, tallerUncheckedCreateWithoutComprobantesInput>
    connectOrCreate?: tallerCreateOrConnectWithoutComprobantesInput
    upsert?: tallerUpsertWithoutComprobantesInput
    disconnect?: tallerWhereInput | boolean
    delete?: tallerWhereInput | boolean
    connect?: tallerWhereUniqueInput
    update?: XOR<XOR<tallerUpdateToOneWithWhereWithoutComprobantesInput, tallerUpdateWithoutComprobantesInput>, tallerUncheckedUpdateWithoutComprobantesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type tallerCreateWithoutMaestroInput = {
    nombre: string
    fecha_ini: Date | string
    fecha_fin?: Date | string | null
    horario?: string | null
    dias?: string | null
    auxiliar?: string | null
    cupo: number
    alumnos?: alumno_tallerCreateNestedManyWithoutTallerInput
    comprobantes?: comprobanteCreateNestedManyWithoutTallerInput
  }

  export type tallerUncheckedCreateWithoutMaestroInput = {
    id_taller?: number
    nombre: string
    fecha_ini: Date | string
    fecha_fin?: Date | string | null
    horario?: string | null
    dias?: string | null
    auxiliar?: string | null
    cupo: number
    alumnos?: alumno_tallerUncheckedCreateNestedManyWithoutTallerInput
    comprobantes?: comprobanteUncheckedCreateNestedManyWithoutTallerInput
  }

  export type tallerCreateOrConnectWithoutMaestroInput = {
    where: tallerWhereUniqueInput
    create: XOR<tallerCreateWithoutMaestroInput, tallerUncheckedCreateWithoutMaestroInput>
  }

  export type tallerCreateManyMaestroInputEnvelope = {
    data: tallerCreateManyMaestroInput | tallerCreateManyMaestroInput[]
    skipDuplicates?: boolean
  }

  export type tallerUpsertWithWhereUniqueWithoutMaestroInput = {
    where: tallerWhereUniqueInput
    update: XOR<tallerUpdateWithoutMaestroInput, tallerUncheckedUpdateWithoutMaestroInput>
    create: XOR<tallerCreateWithoutMaestroInput, tallerUncheckedCreateWithoutMaestroInput>
  }

  export type tallerUpdateWithWhereUniqueWithoutMaestroInput = {
    where: tallerWhereUniqueInput
    data: XOR<tallerUpdateWithoutMaestroInput, tallerUncheckedUpdateWithoutMaestroInput>
  }

  export type tallerUpdateManyWithWhereWithoutMaestroInput = {
    where: tallerScalarWhereInput
    data: XOR<tallerUpdateManyMutationInput, tallerUncheckedUpdateManyWithoutMaestroInput>
  }

  export type tallerScalarWhereInput = {
    AND?: tallerScalarWhereInput | tallerScalarWhereInput[]
    OR?: tallerScalarWhereInput[]
    NOT?: tallerScalarWhereInput | tallerScalarWhereInput[]
    id_taller?: IntFilter<"taller"> | number
    id_maestro?: IntFilter<"taller"> | number
    nombre?: StringFilter<"taller"> | string
    fecha_ini?: DateTimeFilter<"taller"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"taller"> | Date | string | null
    horario?: StringNullableFilter<"taller"> | string | null
    dias?: StringNullableFilter<"taller"> | string | null
    auxiliar?: StringNullableFilter<"taller"> | string | null
    cupo?: IntFilter<"taller"> | number
  }

  export type alumno_tallerCreateWithoutAlumnoInput = {
    fecha_inscripcion?: Date | string
    horas_asignadas?: number
    taller: tallerCreateNestedOneWithoutAlumnosInput
  }

  export type alumno_tallerUncheckedCreateWithoutAlumnoInput = {
    id?: number
    id_taller: number
    fecha_inscripcion?: Date | string
    horas_asignadas?: number
  }

  export type alumno_tallerCreateOrConnectWithoutAlumnoInput = {
    where: alumno_tallerWhereUniqueInput
    create: XOR<alumno_tallerCreateWithoutAlumnoInput, alumno_tallerUncheckedCreateWithoutAlumnoInput>
  }

  export type alumno_tallerCreateManyAlumnoInputEnvelope = {
    data: alumno_tallerCreateManyAlumnoInput | alumno_tallerCreateManyAlumnoInput[]
    skipDuplicates?: boolean
  }

  export type comprobanteCreateWithoutAlumnoInput = {
    fecha_pago: Date | string
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    taller?: tallerCreateNestedOneWithoutComprobantesInput
  }

  export type comprobanteUncheckedCreateWithoutAlumnoInput = {
    id_comprobante?: number
    id_taller?: number | null
    fecha_pago: Date | string
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
  }

  export type comprobanteCreateOrConnectWithoutAlumnoInput = {
    where: comprobanteWhereUniqueInput
    create: XOR<comprobanteCreateWithoutAlumnoInput, comprobanteUncheckedCreateWithoutAlumnoInput>
  }

  export type comprobanteCreateManyAlumnoInputEnvelope = {
    data: comprobanteCreateManyAlumnoInput | comprobanteCreateManyAlumnoInput[]
    skipDuplicates?: boolean
  }

  export type alumno_tallerUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: alumno_tallerWhereUniqueInput
    update: XOR<alumno_tallerUpdateWithoutAlumnoInput, alumno_tallerUncheckedUpdateWithoutAlumnoInput>
    create: XOR<alumno_tallerCreateWithoutAlumnoInput, alumno_tallerUncheckedCreateWithoutAlumnoInput>
  }

  export type alumno_tallerUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: alumno_tallerWhereUniqueInput
    data: XOR<alumno_tallerUpdateWithoutAlumnoInput, alumno_tallerUncheckedUpdateWithoutAlumnoInput>
  }

  export type alumno_tallerUpdateManyWithWhereWithoutAlumnoInput = {
    where: alumno_tallerScalarWhereInput
    data: XOR<alumno_tallerUpdateManyMutationInput, alumno_tallerUncheckedUpdateManyWithoutAlumnoInput>
  }

  export type alumno_tallerScalarWhereInput = {
    AND?: alumno_tallerScalarWhereInput | alumno_tallerScalarWhereInput[]
    OR?: alumno_tallerScalarWhereInput[]
    NOT?: alumno_tallerScalarWhereInput | alumno_tallerScalarWhereInput[]
    id?: IntFilter<"alumno_taller"> | number
    id_alumno?: IntFilter<"alumno_taller"> | number
    id_taller?: IntFilter<"alumno_taller"> | number
    fecha_inscripcion?: DateTimeFilter<"alumno_taller"> | Date | string
    horas_asignadas?: IntFilter<"alumno_taller"> | number
  }

  export type comprobanteUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: comprobanteWhereUniqueInput
    update: XOR<comprobanteUpdateWithoutAlumnoInput, comprobanteUncheckedUpdateWithoutAlumnoInput>
    create: XOR<comprobanteCreateWithoutAlumnoInput, comprobanteUncheckedCreateWithoutAlumnoInput>
  }

  export type comprobanteUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: comprobanteWhereUniqueInput
    data: XOR<comprobanteUpdateWithoutAlumnoInput, comprobanteUncheckedUpdateWithoutAlumnoInput>
  }

  export type comprobanteUpdateManyWithWhereWithoutAlumnoInput = {
    where: comprobanteScalarWhereInput
    data: XOR<comprobanteUpdateManyMutationInput, comprobanteUncheckedUpdateManyWithoutAlumnoInput>
  }

  export type comprobanteScalarWhereInput = {
    AND?: comprobanteScalarWhereInput | comprobanteScalarWhereInput[]
    OR?: comprobanteScalarWhereInput[]
    NOT?: comprobanteScalarWhereInput | comprobanteScalarWhereInput[]
    id_comprobante?: IntFilter<"comprobante"> | number
    id_alumno?: IntFilter<"comprobante"> | number
    id_taller?: IntNullableFilter<"comprobante"> | number | null
    fecha_pago?: DateTimeFilter<"comprobante"> | Date | string
    monto?: DecimalFilter<"comprobante"> | Decimal | DecimalJsLike | number | string
    estado?: StringFilter<"comprobante"> | string
  }

  export type maestroCreateWithoutTalleresInput = {
    nombre: string
    apellido: string
    dni?: string | null
    telefono?: string | null
    cant_talleres?: number
  }

  export type maestroUncheckedCreateWithoutTalleresInput = {
    id_maestro?: number
    nombre: string
    apellido: string
    dni?: string | null
    telefono?: string | null
    cant_talleres?: number
  }

  export type maestroCreateOrConnectWithoutTalleresInput = {
    where: maestroWhereUniqueInput
    create: XOR<maestroCreateWithoutTalleresInput, maestroUncheckedCreateWithoutTalleresInput>
  }

  export type alumno_tallerCreateWithoutTallerInput = {
    fecha_inscripcion?: Date | string
    horas_asignadas?: number
    alumno: alumnoCreateNestedOneWithoutInscripcionesInput
  }

  export type alumno_tallerUncheckedCreateWithoutTallerInput = {
    id?: number
    id_alumno: number
    fecha_inscripcion?: Date | string
    horas_asignadas?: number
  }

  export type alumno_tallerCreateOrConnectWithoutTallerInput = {
    where: alumno_tallerWhereUniqueInput
    create: XOR<alumno_tallerCreateWithoutTallerInput, alumno_tallerUncheckedCreateWithoutTallerInput>
  }

  export type alumno_tallerCreateManyTallerInputEnvelope = {
    data: alumno_tallerCreateManyTallerInput | alumno_tallerCreateManyTallerInput[]
    skipDuplicates?: boolean
  }

  export type comprobanteCreateWithoutTallerInput = {
    fecha_pago: Date | string
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    alumno: alumnoCreateNestedOneWithoutComprobantesInput
  }

  export type comprobanteUncheckedCreateWithoutTallerInput = {
    id_comprobante?: number
    id_alumno: number
    fecha_pago: Date | string
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
  }

  export type comprobanteCreateOrConnectWithoutTallerInput = {
    where: comprobanteWhereUniqueInput
    create: XOR<comprobanteCreateWithoutTallerInput, comprobanteUncheckedCreateWithoutTallerInput>
  }

  export type comprobanteCreateManyTallerInputEnvelope = {
    data: comprobanteCreateManyTallerInput | comprobanteCreateManyTallerInput[]
    skipDuplicates?: boolean
  }

  export type maestroUpsertWithoutTalleresInput = {
    update: XOR<maestroUpdateWithoutTalleresInput, maestroUncheckedUpdateWithoutTalleresInput>
    create: XOR<maestroCreateWithoutTalleresInput, maestroUncheckedCreateWithoutTalleresInput>
    where?: maestroWhereInput
  }

  export type maestroUpdateToOneWithWhereWithoutTalleresInput = {
    where?: maestroWhereInput
    data: XOR<maestroUpdateWithoutTalleresInput, maestroUncheckedUpdateWithoutTalleresInput>
  }

  export type maestroUpdateWithoutTalleresInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cant_talleres?: IntFieldUpdateOperationsInput | number
  }

  export type maestroUncheckedUpdateWithoutTalleresInput = {
    id_maestro?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cant_talleres?: IntFieldUpdateOperationsInput | number
  }

  export type alumno_tallerUpsertWithWhereUniqueWithoutTallerInput = {
    where: alumno_tallerWhereUniqueInput
    update: XOR<alumno_tallerUpdateWithoutTallerInput, alumno_tallerUncheckedUpdateWithoutTallerInput>
    create: XOR<alumno_tallerCreateWithoutTallerInput, alumno_tallerUncheckedCreateWithoutTallerInput>
  }

  export type alumno_tallerUpdateWithWhereUniqueWithoutTallerInput = {
    where: alumno_tallerWhereUniqueInput
    data: XOR<alumno_tallerUpdateWithoutTallerInput, alumno_tallerUncheckedUpdateWithoutTallerInput>
  }

  export type alumno_tallerUpdateManyWithWhereWithoutTallerInput = {
    where: alumno_tallerScalarWhereInput
    data: XOR<alumno_tallerUpdateManyMutationInput, alumno_tallerUncheckedUpdateManyWithoutTallerInput>
  }

  export type comprobanteUpsertWithWhereUniqueWithoutTallerInput = {
    where: comprobanteWhereUniqueInput
    update: XOR<comprobanteUpdateWithoutTallerInput, comprobanteUncheckedUpdateWithoutTallerInput>
    create: XOR<comprobanteCreateWithoutTallerInput, comprobanteUncheckedCreateWithoutTallerInput>
  }

  export type comprobanteUpdateWithWhereUniqueWithoutTallerInput = {
    where: comprobanteWhereUniqueInput
    data: XOR<comprobanteUpdateWithoutTallerInput, comprobanteUncheckedUpdateWithoutTallerInput>
  }

  export type comprobanteUpdateManyWithWhereWithoutTallerInput = {
    where: comprobanteScalarWhereInput
    data: XOR<comprobanteUpdateManyMutationInput, comprobanteUncheckedUpdateManyWithoutTallerInput>
  }

  export type alumnoCreateWithoutInscripcionesInput = {
    nombre: string
    apellido: string
    dni?: string | null
    direccion?: string | null
    telefono_madre?: string | null
    telefono_padre?: string | null
    comprobantes?: comprobanteCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoUncheckedCreateWithoutInscripcionesInput = {
    id_alumno?: number
    nombre: string
    apellido: string
    dni?: string | null
    direccion?: string | null
    telefono_madre?: string | null
    telefono_padre?: string | null
    comprobantes?: comprobanteUncheckedCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoCreateOrConnectWithoutInscripcionesInput = {
    where: alumnoWhereUniqueInput
    create: XOR<alumnoCreateWithoutInscripcionesInput, alumnoUncheckedCreateWithoutInscripcionesInput>
  }

  export type tallerCreateWithoutAlumnosInput = {
    nombre: string
    fecha_ini: Date | string
    fecha_fin?: Date | string | null
    horario?: string | null
    dias?: string | null
    auxiliar?: string | null
    cupo: number
    maestro: maestroCreateNestedOneWithoutTalleresInput
    comprobantes?: comprobanteCreateNestedManyWithoutTallerInput
  }

  export type tallerUncheckedCreateWithoutAlumnosInput = {
    id_taller?: number
    id_maestro: number
    nombre: string
    fecha_ini: Date | string
    fecha_fin?: Date | string | null
    horario?: string | null
    dias?: string | null
    auxiliar?: string | null
    cupo: number
    comprobantes?: comprobanteUncheckedCreateNestedManyWithoutTallerInput
  }

  export type tallerCreateOrConnectWithoutAlumnosInput = {
    where: tallerWhereUniqueInput
    create: XOR<tallerCreateWithoutAlumnosInput, tallerUncheckedCreateWithoutAlumnosInput>
  }

  export type alumnoUpsertWithoutInscripcionesInput = {
    update: XOR<alumnoUpdateWithoutInscripcionesInput, alumnoUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<alumnoCreateWithoutInscripcionesInput, alumnoUncheckedCreateWithoutInscripcionesInput>
    where?: alumnoWhereInput
  }

  export type alumnoUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: alumnoWhereInput
    data: XOR<alumnoUpdateWithoutInscripcionesInput, alumnoUncheckedUpdateWithoutInscripcionesInput>
  }

  export type alumnoUpdateWithoutInscripcionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_madre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_padre?: NullableStringFieldUpdateOperationsInput | string | null
    comprobantes?: comprobanteUpdateManyWithoutAlumnoNestedInput
  }

  export type alumnoUncheckedUpdateWithoutInscripcionesInput = {
    id_alumno?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_madre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_padre?: NullableStringFieldUpdateOperationsInput | string | null
    comprobantes?: comprobanteUncheckedUpdateManyWithoutAlumnoNestedInput
  }

  export type tallerUpsertWithoutAlumnosInput = {
    update: XOR<tallerUpdateWithoutAlumnosInput, tallerUncheckedUpdateWithoutAlumnosInput>
    create: XOR<tallerCreateWithoutAlumnosInput, tallerUncheckedCreateWithoutAlumnosInput>
    where?: tallerWhereInput
  }

  export type tallerUpdateToOneWithWhereWithoutAlumnosInput = {
    where?: tallerWhereInput
    data: XOR<tallerUpdateWithoutAlumnosInput, tallerUncheckedUpdateWithoutAlumnosInput>
  }

  export type tallerUpdateWithoutAlumnosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
    maestro?: maestroUpdateOneRequiredWithoutTalleresNestedInput
    comprobantes?: comprobanteUpdateManyWithoutTallerNestedInput
  }

  export type tallerUncheckedUpdateWithoutAlumnosInput = {
    id_taller?: IntFieldUpdateOperationsInput | number
    id_maestro?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
    comprobantes?: comprobanteUncheckedUpdateManyWithoutTallerNestedInput
  }

  export type alumnoCreateWithoutComprobantesInput = {
    nombre: string
    apellido: string
    dni?: string | null
    direccion?: string | null
    telefono_madre?: string | null
    telefono_padre?: string | null
    inscripciones?: alumno_tallerCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoUncheckedCreateWithoutComprobantesInput = {
    id_alumno?: number
    nombre: string
    apellido: string
    dni?: string | null
    direccion?: string | null
    telefono_madre?: string | null
    telefono_padre?: string | null
    inscripciones?: alumno_tallerUncheckedCreateNestedManyWithoutAlumnoInput
  }

  export type alumnoCreateOrConnectWithoutComprobantesInput = {
    where: alumnoWhereUniqueInput
    create: XOR<alumnoCreateWithoutComprobantesInput, alumnoUncheckedCreateWithoutComprobantesInput>
  }

  export type tallerCreateWithoutComprobantesInput = {
    nombre: string
    fecha_ini: Date | string
    fecha_fin?: Date | string | null
    horario?: string | null
    dias?: string | null
    auxiliar?: string | null
    cupo: number
    maestro: maestroCreateNestedOneWithoutTalleresInput
    alumnos?: alumno_tallerCreateNestedManyWithoutTallerInput
  }

  export type tallerUncheckedCreateWithoutComprobantesInput = {
    id_taller?: number
    id_maestro: number
    nombre: string
    fecha_ini: Date | string
    fecha_fin?: Date | string | null
    horario?: string | null
    dias?: string | null
    auxiliar?: string | null
    cupo: number
    alumnos?: alumno_tallerUncheckedCreateNestedManyWithoutTallerInput
  }

  export type tallerCreateOrConnectWithoutComprobantesInput = {
    where: tallerWhereUniqueInput
    create: XOR<tallerCreateWithoutComprobantesInput, tallerUncheckedCreateWithoutComprobantesInput>
  }

  export type alumnoUpsertWithoutComprobantesInput = {
    update: XOR<alumnoUpdateWithoutComprobantesInput, alumnoUncheckedUpdateWithoutComprobantesInput>
    create: XOR<alumnoCreateWithoutComprobantesInput, alumnoUncheckedCreateWithoutComprobantesInput>
    where?: alumnoWhereInput
  }

  export type alumnoUpdateToOneWithWhereWithoutComprobantesInput = {
    where?: alumnoWhereInput
    data: XOR<alumnoUpdateWithoutComprobantesInput, alumnoUncheckedUpdateWithoutComprobantesInput>
  }

  export type alumnoUpdateWithoutComprobantesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_madre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_padre?: NullableStringFieldUpdateOperationsInput | string | null
    inscripciones?: alumno_tallerUpdateManyWithoutAlumnoNestedInput
  }

  export type alumnoUncheckedUpdateWithoutComprobantesInput = {
    id_alumno?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_madre?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_padre?: NullableStringFieldUpdateOperationsInput | string | null
    inscripciones?: alumno_tallerUncheckedUpdateManyWithoutAlumnoNestedInput
  }

  export type tallerUpsertWithoutComprobantesInput = {
    update: XOR<tallerUpdateWithoutComprobantesInput, tallerUncheckedUpdateWithoutComprobantesInput>
    create: XOR<tallerCreateWithoutComprobantesInput, tallerUncheckedCreateWithoutComprobantesInput>
    where?: tallerWhereInput
  }

  export type tallerUpdateToOneWithWhereWithoutComprobantesInput = {
    where?: tallerWhereInput
    data: XOR<tallerUpdateWithoutComprobantesInput, tallerUncheckedUpdateWithoutComprobantesInput>
  }

  export type tallerUpdateWithoutComprobantesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
    maestro?: maestroUpdateOneRequiredWithoutTalleresNestedInput
    alumnos?: alumno_tallerUpdateManyWithoutTallerNestedInput
  }

  export type tallerUncheckedUpdateWithoutComprobantesInput = {
    id_taller?: IntFieldUpdateOperationsInput | number
    id_maestro?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
    alumnos?: alumno_tallerUncheckedUpdateManyWithoutTallerNestedInput
  }

  export type tallerCreateManyMaestroInput = {
    id_taller?: number
    nombre: string
    fecha_ini: Date | string
    fecha_fin?: Date | string | null
    horario?: string | null
    dias?: string | null
    auxiliar?: string | null
    cupo: number
  }

  export type tallerUpdateWithoutMaestroInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
    alumnos?: alumno_tallerUpdateManyWithoutTallerNestedInput
    comprobantes?: comprobanteUpdateManyWithoutTallerNestedInput
  }

  export type tallerUncheckedUpdateWithoutMaestroInput = {
    id_taller?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
    alumnos?: alumno_tallerUncheckedUpdateManyWithoutTallerNestedInput
    comprobantes?: comprobanteUncheckedUpdateManyWithoutTallerNestedInput
  }

  export type tallerUncheckedUpdateManyWithoutMaestroInput = {
    id_taller?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fecha_ini?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horario?: NullableStringFieldUpdateOperationsInput | string | null
    dias?: NullableStringFieldUpdateOperationsInput | string | null
    auxiliar?: NullableStringFieldUpdateOperationsInput | string | null
    cupo?: IntFieldUpdateOperationsInput | number
  }

  export type alumno_tallerCreateManyAlumnoInput = {
    id?: number
    id_taller: number
    fecha_inscripcion?: Date | string
    horas_asignadas?: number
  }

  export type comprobanteCreateManyAlumnoInput = {
    id_comprobante?: number
    id_taller?: number | null
    fecha_pago: Date | string
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
  }

  export type alumno_tallerUpdateWithoutAlumnoInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    horas_asignadas?: IntFieldUpdateOperationsInput | number
    taller?: tallerUpdateOneRequiredWithoutAlumnosNestedInput
  }

  export type alumno_tallerUncheckedUpdateWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_taller?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    horas_asignadas?: IntFieldUpdateOperationsInput | number
  }

  export type alumno_tallerUncheckedUpdateManyWithoutAlumnoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_taller?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    horas_asignadas?: IntFieldUpdateOperationsInput | number
  }

  export type comprobanteUpdateWithoutAlumnoInput = {
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    taller?: tallerUpdateOneWithoutComprobantesNestedInput
  }

  export type comprobanteUncheckedUpdateWithoutAlumnoInput = {
    id_comprobante?: IntFieldUpdateOperationsInput | number
    id_taller?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type comprobanteUncheckedUpdateManyWithoutAlumnoInput = {
    id_comprobante?: IntFieldUpdateOperationsInput | number
    id_taller?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type alumno_tallerCreateManyTallerInput = {
    id?: number
    id_alumno: number
    fecha_inscripcion?: Date | string
    horas_asignadas?: number
  }

  export type comprobanteCreateManyTallerInput = {
    id_comprobante?: number
    id_alumno: number
    fecha_pago: Date | string
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
  }

  export type alumno_tallerUpdateWithoutTallerInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    horas_asignadas?: IntFieldUpdateOperationsInput | number
    alumno?: alumnoUpdateOneRequiredWithoutInscripcionesNestedInput
  }

  export type alumno_tallerUncheckedUpdateWithoutTallerInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_alumno?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    horas_asignadas?: IntFieldUpdateOperationsInput | number
  }

  export type alumno_tallerUncheckedUpdateManyWithoutTallerInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_alumno?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    horas_asignadas?: IntFieldUpdateOperationsInput | number
  }

  export type comprobanteUpdateWithoutTallerInput = {
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    alumno?: alumnoUpdateOneRequiredWithoutComprobantesNestedInput
  }

  export type comprobanteUncheckedUpdateWithoutTallerInput = {
    id_comprobante?: IntFieldUpdateOperationsInput | number
    id_alumno?: IntFieldUpdateOperationsInput | number
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type comprobanteUncheckedUpdateManyWithoutTallerInput = {
    id_comprobante?: IntFieldUpdateOperationsInput | number
    id_alumno?: IntFieldUpdateOperationsInput | number
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MaestroCountOutputTypeDefaultArgs instead
     */
    export type MaestroCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaestroCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlumnoCountOutputTypeDefaultArgs instead
     */
    export type AlumnoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlumnoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TallerCountOutputTypeDefaultArgs instead
     */
    export type TallerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TallerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use maestroDefaultArgs instead
     */
    export type maestroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = maestroDefaultArgs<ExtArgs>
    /**
     * @deprecated Use alumnoDefaultArgs instead
     */
    export type alumnoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = alumnoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tallerDefaultArgs instead
     */
    export type tallerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tallerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use alumno_tallerDefaultArgs instead
     */
    export type alumno_tallerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = alumno_tallerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use comprobanteDefaultArgs instead
     */
    export type comprobanteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = comprobanteDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}